[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to R for SAS programmers",
    "section": "",
    "text": "On this page you find the materials for the workshop Introduction to R for SAS programmers. The workshop provides an RStudio cloud workspace, so you don’t need to have R and RStudio locally installed.\nIf you want to participate in this workshop using your local machine, you need to download the data first. Executing the following chunk in R on your machine will create and populate a data folder in your current working directory. If you work on the RStudio cloud instance provided by us via link, you do not need to run this chunk.\n\n# set paths and data names\nexternal.path <- \n  \"https://github.com/pharmaverse/intro-to-r-for-sas-programmers-workshop/blob/main/data\"\n\nlocal.path <- (\"data\")\nsubdir <- file.path(local.path, \"save_data\")\nfiles <- c(\n  \"adsl.RData\", \n  \"adsl.csv\", \n  \"adsl.sas7bdat\", \n  \"adsl_1.RData\", \n  \"adsl_2.RData\", \n  \"ae.rds\", \n  \"dm.rds\", \n  \"ds.rds\",\n  \"ex.rds\",\n  \"suppdm.rds\",\n  \"suppds.rds\"\n  )\n\n# external files (with path)\nurls <- file.path(external.path, paste(files, \"raw=true\", sep = \"?\"))\n# local files (with path)\ndest <- file.path(local.path, files)\n\n# create data folder in wd\nif (!file.exists(local.path)) {\n  dir.create(local.path)\n  # subdirectory\n  dir.create(subdir)\n}\n\n# download files if needed\ndownload.file(urls, destfile = dest)\n\n\n\n\n\nYou can’t get enough? Here is a resource to help transitioning from SAS to R."
  },
  {
    "objectID": "datatype_structure.html",
    "href": "datatype_structure.html",
    "title": "1  datatype and structure",
    "section": "",
    "text": "R can be used as a calculator following the order of operations using the basic arithmetic operators, although, the arithmetic equal sign (=) in the equivalent of ==.\n\n# simple calculations \n3*2\n\n[1] 6\n\n(59 + 73 + 2) / 3\n\n[1] 44.66667\n\n# complex calculations\npi/8\n\n[1] 0.3926991"
  },
  {
    "objectID": "datatype_structure.html#storing-outputs",
    "href": "datatype_structure.html#storing-outputs",
    "title": "1  datatype and structure",
    "section": "1.2 Storing outputs",
    "text": "1.2 Storing outputs\nAn object can be created to assign the value of your operation to a specific variable name, which can be reused later in the R session. Using the object_name <- value naming convention, you can assign (<-) the value ((59 + 73 + 2) / 3) to an object_name simple_cal to look like simple_cal <- (59 + 73 + 2) / 3 to store the evaluation of that calculation.\n\nx <- 1:10\n\ny <- 2*x\n\nsimple_cal <- (59 + 73 + 2) / 3"
  },
  {
    "objectID": "datatype_structure.html#loading-data-into-r",
    "href": "datatype_structure.html#loading-data-into-r",
    "title": "1  datatype and structure",
    "section": "1.3 Loading data into R",
    "text": "1.3 Loading data into R\nDepending on the formats for the files containing your data, we can use different base R functions to read and load data into memory\nR has two native data formats, Rdata (sometimes call Rda) and RDS.\nRdata can be selected R objects or a workspace, and RDS are single R object. R has base functions available to read the two native data formats, and some delimited files.\n\n# saving rdata\nsave(x, file = \"data/intro_1.RData\")\n# Save multiple objects\nsave(x, y, file = \"data/intro_2.RData\")\n\n# Saving the entire workspake \nsave.image(file=\"data/intro_program.RData\")\n\n# We can follow the syntax for saving single Rdata object to save Rds files\n# saveRDS(object, file = \"my_data.rds\")\n\n\n# loading Rdata or Rda files \nload(file = \"data/intro_program.RData\")\n\n# loading RDS\n# We can follow the syntax for read Rdata object to sread Rds files using the readRDS()\n\n\n# Comma delimited\nadsl_CSV <- read.csv(\"data/adsl.csv\", header = TRUE)\n\n# Save CSV\nadsl_csv_save <- write.csv(adsl_CSV, \"data/save_data/adsl.csv\", row.names=TRUE)\n\n\nadsl_TAB_save <- write.table(\n  adsl_CSV,\n  \"data/save_data/adsl.txt\",\n  append = FALSE,\n  sep = \"\\t\",\n  dec = \".\",\n  row.names = TRUE,\n  col.names = TRUE\n)\n\n# Tab-delimited \nadsl_TAB <- read.table(\"data/save_data/adsl.txt\", header = TRUE, sep = \"\\t\")"
  },
  {
    "objectID": "datatype_structure.html#r-packages",
    "href": "datatype_structure.html#r-packages",
    "title": "1  datatype and structure",
    "section": "1.4 R Packages",
    "text": "1.4 R Packages\nR packages are a collection of reusable functions, compiled codes, documentation, sample data and tests. Some formats of data require the use of an R package in order to load that data into memory. Share-able R packages are typically stored in a repository such as the Comprehensive R Archive Network (CRAN), Bioconductor, and GitHub."
  },
  {
    "objectID": "datatype_structure.html#installing-r-packages",
    "href": "datatype_structure.html#installing-r-packages",
    "title": "1  datatype and structure",
    "section": "1.5 Installing R packages",
    "text": "1.5 Installing R packages\n\n# From CRAN\n#install.packages(\"insert_package_name\")\n# {haven} is used to import or export foreign statistical format files (SPSS, Stata, SAS)\ninstall.packages(\"haven\")\n\n# {readxl}\ninstall.packages(\"readxl\")\n\n\n# From Github\nremotes::install_github(\"pharmaverse/admiral\", ref = \"devel\")"
  },
  {
    "objectID": "datatype_structure.html#using-r-packages-functions-from-an-r-package-and-accessing-help-pages",
    "href": "datatype_structure.html#using-r-packages-functions-from-an-r-package-and-accessing-help-pages",
    "title": "1  datatype and structure",
    "section": "1.6 Using R packages, functions from an R package, and accessing help pages",
    "text": "1.6 Using R packages, functions from an R package, and accessing help pages\nSince an R packages are a collection of functions, you can choose to load the entire package within R memory or just the needed function from that package. Usually, the order you choose to load your package does not make a difference, unless you are loading two or more packages that has functions with the same name. If you are loading two or more packages with common function name, then the package loaded last will hide that function in the earlier packages, so in that case is important to note the order you choose to load the packages.\n\n# Read file using ::\nadsl_sas1 <- haven::read_sas(\"data/adsl.sas7bdat\")\n\n# read file using library call  \nlibrary(haven)\nadsl_sas2 <- read_sas(\"data/adsl.sas7bdat\")\n\n\n# Reading Excel xls|xlsx files\n# read_excel reads both xls|xlsx files but read_xls and read_xlsx can also be used to read respective files\n\n# if NA are represented by another something other than blank then you can specified the NA value\n# within the read_excel() function"
  },
  {
    "objectID": "datatype_structure.html#data-types",
    "href": "datatype_structure.html#data-types",
    "title": "1  datatype and structure",
    "section": "1.7 Data types",
    "text": "1.7 Data types\nR has different types of Datatype\n* Integer * numeric * Character * Logical * complex * raw\nBut we will focus on the top 4.\n\nset.seed(1234)\n\ntype_int <- (1:5) \ntype_num <- rnorm(5)\ntype_char <- \"USUBJID\"\ntype_logl_1 <- TRUE\ntype_logl_2 <- FALSE\n\n\nclass(type_int)\n\n[1] \"integer\"\n\nclass(type_num)\n\n[1] \"numeric\"\n\nclass(type_logl_1)\n\n[1] \"logical\"\n\nclass(type_logl_2)\n\n[1] \"logical\"\n\nclass(type_char)\n\n[1] \"character\""
  },
  {
    "objectID": "datatype_structure.html#date-formats",
    "href": "datatype_structure.html#date-formats",
    "title": "1  datatype and structure",
    "section": "1.8 Date formats",
    "text": "1.8 Date formats\nThere are base R functions that can be used to format a date object similar to the Date9 formatted date variable from SAS. In addition, there are R packages available, such as {lubridate}, for more complex date/date time formatted objects.\n\n# using adsl_sas1 RFSTDTC\nclass(adsl_sas1$RFSTDTC)\n\n[1] \"character\"\n\n# Convert the date from that adsl_sas1 into a date variable\nadsl_sas1$RFSTDTC <- as.Date(adsl_sas1$RFSTDTC)\nclass(adsl_sas1$RFSTDTC)\n\n[1] \"Date\"\n\ndate9 <- lubridate::as_date(18757)\nlubridate::mdy(adsl_sas1$RFSTDTC)\n\nWarning: All formats failed to parse. No formats found.\n\n\n  [1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [51] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n [76] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[101] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[126] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[151] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[176] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[201] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[226] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[251] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[276] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA\n[301] NA NA NA NA NA NA"
  },
  {
    "objectID": "datatype_structure.html#structures",
    "href": "datatype_structure.html#structures",
    "title": "1  datatype and structure",
    "section": "1.9 Structures",
    "text": "1.9 Structures\nData structures are dimensional ways of organizing the data. There are different data structures in R, let’s focus on vectors and dataframe\nVectors are 1 dimensional collection of data that can contain one or more element of the same data type\n\nvect_1 <- 2\nvect_2 <- c(2, \"USUBJID\")\n\nclass(vect_1)\n\n[1] \"numeric\"\n\nclass(vect_2)\n\n[1] \"character\"\n\n# Saving vectors from a dataset to a specific variable\nusubjid <- adsl_sas1$USUBJID\nsubjid <- adsl_sas1[, 3]\n\nDataframe is similar to SAS data sets and are 2 dimensional collection of vectors. Dataframe can store vectors of different types but must be of the same length\n\ndf <- data.frame(\n  age = c(65, 20, 37,19,45),\n  seq = (1:5),\n  type_logl = c(TRUE,FALSE, TRUE, TRUE, FALSE),\n  usubjid = c(\"001-940-9785\",\"002-950-9726\",\"003-940-9767\",\"004-940-9795\",\"005-940-9734\")\n)\n\n# str() provides the data structure for each object in the dataframe\nstr(df)\n\n'data.frame':   5 obs. of  4 variables:\n $ age      : num  65 20 37 19 45\n $ seq      : int  1 2 3 4 5\n $ type_logl: logi  TRUE FALSE TRUE TRUE FALSE\n $ usubjid  : chr  \"001-940-9785\" \"002-950-9726\" \"003-940-9767\" \"004-940-9795\" ...\n\n# In addition to the data structure per variable, also get some descriptive statistics \nsummary(df)\n\n      age            seq    type_logl         usubjid         \n Min.   :19.0   Min.   :1   Mode :logical   Length:5          \n 1st Qu.:20.0   1st Qu.:2   FALSE:2         Class :character  \n Median :37.0   Median :3   TRUE :3         Mode  :character  \n Mean   :37.2   Mean   :3                                     \n 3rd Qu.:45.0   3rd Qu.:4                                     \n Max.   :65.0   Max.   :5"
  },
  {
    "objectID": "datatype_structure_exercise.html",
    "href": "datatype_structure_exercise.html",
    "title": "2  datatype and structure exercise",
    "section": "",
    "text": "4 Exercise 2\nImport adsl.sas7bdat as adsl\n\n\nShow solution\nadsl <-  haven::read_sas(\"data/adsl.sas7bdat\")"
  },
  {
    "objectID": "dplyr.html",
    "href": "dplyr.html",
    "title": "3  dplyr",
    "section": "",
    "text": "The tidyverse is a collection of R packages designed for data science. It includes packages such as ggplot2 for data visualization, dplyr for data manipulation, and tidyr for reshaping data. The tidyverse is built around the idea of “tidy data,” which is a standardized way of organizing and structuring data for analysis. The packages in the tidyverse are designed to work together seamlessly, making it a popular choice for data scientists and analysts who use R."
  },
  {
    "objectID": "dplyr.html#setup",
    "href": "dplyr.html#setup",
    "title": "3  dplyr",
    "section": "3.1 Setup",
    "text": "3.1 Setup\n\nlibrary(tidyverse)\n\nRead data\n\nadsl <- read_csv(\"data/adsl.csv\")\n\nRows: 306 Columns: 50\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (23): STUDYID, USUBJID, DTHFL, AGEU, SEX, RACE, ETHNIC, ARMCD, ARM, ACT...\ndbl   (7): SUBJID, SITEID, AGE, DMDY, TRTDURD, DTHADY, LDDTHELD\nlgl   (3): RFICDTC, REGION1, DTHA30FL\ndttm  (3): RFPENDTC, TRTSDTM, TRTEDTM\ndate (14): RFSTDTC, RFENDTC, RFXSTDTC, RFXENDTC, DTHDTC, DMDTC, TRTSDT, TRTE...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\nWe can have a look at the data using many different commands / functions, e.g. the head() function which gives us the first six observations:\n\nhead(adsl)\n\n# A tibble: 6 × 50\n  STUDYID     USUBJID SUBJID RFSTDTC    RFENDTC    RFXSTDTC   RFXENDTC   RFICDTC\n  <chr>       <chr>    <dbl> <date>     <date>     <date>     <date>     <lgl>  \n1 CDISCPILOT… 01-701…   1015 2014-01-02 2014-07-02 2014-01-02 2014-07-02 NA     \n2 CDISCPILOT… 01-701…   1023 2012-08-05 2012-09-02 2012-08-05 2012-09-01 NA     \n3 CDISCPILOT… 01-701…   1028 2013-07-19 2014-01-14 2013-07-19 2014-01-14 NA     \n4 CDISCPILOT… 01-701…   1033 2014-03-18 2014-04-14 2014-03-18 2014-03-31 NA     \n5 CDISCPILOT… 01-701…   1034 2014-07-01 2014-12-30 2014-07-01 2014-12-30 NA     \n6 CDISCPILOT… 01-701…   1047 2013-02-12 2013-03-29 2013-02-12 2013-03-09 NA     \n# … with 42 more variables: RFPENDTC <dttm>, DTHDTC <date>, DTHFL <chr>,\n#   SITEID <dbl>, AGE <dbl>, AGEU <chr>, SEX <chr>, RACE <chr>, ETHNIC <chr>,\n#   ARMCD <chr>, ARM <chr>, ACTARMCD <chr>, ACTARM <chr>, COUNTRY <chr>,\n#   DMDTC <date>, DMDY <dbl>, TRT01P <chr>, TRT01A <chr>, TRTSDTM <dttm>,\n#   TRTSTMF <chr>, TRTEDTM <dttm>, TRTETMF <chr>, TRTSDT <date>, TRTEDT <date>,\n#   TRTDURD <dbl>, SCRFDT <date>, EOSDT <date>, EOSSTT <chr>, FRVDT <date>,\n#   RANDDT <date>, DTHDT <date>, DTHADY <dbl>, LDDTHELD <dbl>, …"
  },
  {
    "objectID": "dplyr.html#dplyr",
    "href": "dplyr.html#dplyr",
    "title": "3  dplyr",
    "section": "3.2 dplyr",
    "text": "3.2 dplyr\ndplyr is a package in the tidyverse that provides a set of functions for efficiently manipulating and cleaning data. It is built around the idea of “verbs” that correspond to common data manipulation tasks, such as select() for selecting specific columns from a data frame, filter() for filtering rows based on certain conditions, arrange() for sorting data-frames and group_by() and summarize() for grouping and summarizing data by one or more variables.\ndplyr is not strictly needed for any of that, everything can be done in base R. However, dplyr provides a framework to write readable code and a pipeline to work efficiently.\nThere are various functions within dplyr for datawrangling which follow a consistent structure. The first input of the most used dplyr functions is the data-frame. Then follow arguments specifying the behaviour of the function. Compared to the base r syntax we do not have to write column / variable names in quotation marks; dplyr syntax lets us refer to columns within a data-frame without the need to always reference the data-frame of origin.\n\n3.2.1 select\nThe select function lets us select all variables mentioned in the arguments (and drops all other variables). Alternatively, we can selectively drop variables if we place a minus (-) in front of the variable name.\nWe can first have a look at all variable names of the data-frame:\n\nnames(adsl)\n\n [1] \"STUDYID\"  \"USUBJID\"  \"SUBJID\"   \"RFSTDTC\"  \"RFENDTC\"  \"RFXSTDTC\"\n [7] \"RFXENDTC\" \"RFICDTC\"  \"RFPENDTC\" \"DTHDTC\"   \"DTHFL\"    \"SITEID\"  \n[13] \"AGE\"      \"AGEU\"     \"SEX\"      \"RACE\"     \"ETHNIC\"   \"ARMCD\"   \n[19] \"ARM\"      \"ACTARMCD\" \"ACTARM\"   \"COUNTRY\"  \"DMDTC\"    \"DMDY\"    \n[25] \"TRT01P\"   \"TRT01A\"   \"TRTSDTM\"  \"TRTSTMF\"  \"TRTEDTM\"  \"TRTETMF\" \n[31] \"TRTSDT\"   \"TRTEDT\"   \"TRTDURD\"  \"SCRFDT\"   \"EOSDT\"    \"EOSSTT\"  \n[37] \"FRVDT\"    \"RANDDT\"   \"DTHDT\"    \"DTHADY\"   \"LDDTHELD\" \"LSTALVDT\"\n[43] \"AGEGR1\"   \"SAFFL\"    \"RACEGR1\"  \"REGION1\"  \"LDDTHGR1\" \"DTH30FL\" \n[49] \"DTHA30FL\" \"DTHB30FL\"\n\n\nAnd then select the desired variables:\n\n# dplyr::select\nselect(adsl, \n       STUDYID, \n       USUBJID, \n       ARM, \n       AGE, \n       SEX, \n       RACE)\n\n# A tibble: 306 × 6\n   STUDYID      USUBJID     ARM                    AGE SEX   RACE \n   <chr>        <chr>       <chr>                <dbl> <chr> <chr>\n 1 CDISCPILOT01 01-701-1015 Placebo                 63 F     WHITE\n 2 CDISCPILOT01 01-701-1023 Placebo                 64 M     WHITE\n 3 CDISCPILOT01 01-701-1028 Xanomeline High Dose    71 M     WHITE\n 4 CDISCPILOT01 01-701-1033 Xanomeline Low Dose     74 M     WHITE\n 5 CDISCPILOT01 01-701-1034 Xanomeline High Dose    77 F     WHITE\n 6 CDISCPILOT01 01-701-1047 Placebo                 85 F     WHITE\n 7 CDISCPILOT01 01-701-1057 Screen Failure          59 F     WHITE\n 8 CDISCPILOT01 01-701-1097 Xanomeline Low Dose     68 M     WHITE\n 9 CDISCPILOT01 01-701-1111 Xanomeline Low Dose     81 F     WHITE\n10 CDISCPILOT01 01-701-1115 Xanomeline Low Dose     84 M     WHITE\n# … with 296 more rows\n\n\nWe end up with a new data-frame including only the selected variables. Note here that we do not save the resulting data-frame at the moment.\nThere are also some helper functions to use within the select function of dplyr. starts_with() ends_with() num_range(). They allow us to select multiple columns sharing a naming structure. num_range() let’s us select consecutively numbered columns, e.g.: num_range(\"example\", 1:4) would select the columns named: example1, example2, example3, example4.\nWe can try out starts_with():\n\nselect(adsl,\n       USUBJID, \n       starts_with(\"trt\"))\n\n# A tibble: 306 × 10\n   USUBJID TRT01P TRT01A TRTSDTM             TRTSTMF TRTEDTM             TRTETMF\n   <chr>   <chr>  <chr>  <dttm>              <chr>   <dttm>              <chr>  \n 1 01-701… Place… Place… 2014-01-02 00:00:00 H       2014-07-02 23:59:59 H      \n 2 01-701… Place… Place… 2012-08-05 00:00:00 H       2012-09-01 23:59:59 H      \n 3 01-701… Xanom… Xanom… 2013-07-19 00:00:00 H       2014-01-14 23:59:59 H      \n 4 01-701… Xanom… Xanom… 2014-03-18 00:00:00 H       2014-03-31 23:59:59 H      \n 5 01-701… Xanom… Xanom… 2014-07-01 00:00:00 H       2014-12-30 23:59:59 H      \n 6 01-701… Place… Place… 2013-02-12 00:00:00 H       2013-03-09 23:59:59 H      \n 7 01-701… Scree… Scree… NA                  <NA>    NA                  <NA>   \n 8 01-701… Xanom… Xanom… 2014-01-01 00:00:00 H       2014-07-09 23:59:59 H      \n 9 01-701… Xanom… Xanom… 2012-09-07 00:00:00 H       2012-09-16 23:59:59 H      \n10 01-701… Xanom… Xanom… 2012-11-30 00:00:00 H       2013-01-23 23:59:59 H      \n# … with 296 more rows, and 3 more variables: TRTSDT <date>, TRTEDT <date>,\n#   TRTDURD <dbl>\n\n\nAnd ends_with():\n\n# in this df, all variables that contain dates end with \"DT\". \n# We can select them:\nselect(adsl,\n       USUBJID, \n       ends_with(\"DT\"))\n\n# A tibble: 306 × 9\n   USUBJID     TRTSDT     TRTEDT     SCRFDT     EOSDT      FRVDT      RANDDT    \n   <chr>       <date>     <date>     <date>     <date>     <date>     <date>    \n 1 01-701-1015 2014-01-02 2014-07-02 NA         2014-07-02 NA         2014-01-02\n 2 01-701-1023 2012-08-05 2012-09-01 NA         2012-09-02 2013-02-18 2012-08-05\n 3 01-701-1028 2013-07-19 2014-01-14 NA         2014-01-14 NA         2013-07-19\n 4 01-701-1033 2014-03-18 2014-03-31 NA         2014-04-14 2014-09-15 2014-03-18\n 5 01-701-1034 2014-07-01 2014-12-30 NA         2014-12-30 NA         2014-07-01\n 6 01-701-1047 2013-02-12 2013-03-09 NA         2013-03-29 2013-07-28 2013-02-12\n 7 01-701-1057 NA         NA         2013-12-20 NA         NA         NA        \n 8 01-701-1097 2014-01-01 2014-07-09 NA         2014-07-09 NA         2014-01-01\n 9 01-701-1111 2012-09-07 2012-09-16 NA         2012-09-17 2013-02-22 2012-09-07\n10 01-701-1115 2012-11-30 2013-01-23 NA         2013-01-23 2013-05-20 2012-11-30\n# … with 296 more rows, and 2 more variables: DTHDT <date>, LSTALVDT <date>\n\n\nIf we want a data-frame that does not include any dates, we can make use of the minus sign in combination with the ends_with() function:\n\nselect(adsl,\n       -ends_with(\"DT\")) \n\n# A tibble: 306 × 42\n   STUDYID    USUBJID SUBJID RFSTDTC    RFENDTC    RFXSTDTC   RFXENDTC   RFICDTC\n   <chr>      <chr>    <dbl> <date>     <date>     <date>     <date>     <lgl>  \n 1 CDISCPILO… 01-701…   1015 2014-01-02 2014-07-02 2014-01-02 2014-07-02 NA     \n 2 CDISCPILO… 01-701…   1023 2012-08-05 2012-09-02 2012-08-05 2012-09-01 NA     \n 3 CDISCPILO… 01-701…   1028 2013-07-19 2014-01-14 2013-07-19 2014-01-14 NA     \n 4 CDISCPILO… 01-701…   1033 2014-03-18 2014-04-14 2014-03-18 2014-03-31 NA     \n 5 CDISCPILO… 01-701…   1034 2014-07-01 2014-12-30 2014-07-01 2014-12-30 NA     \n 6 CDISCPILO… 01-701…   1047 2013-02-12 2013-03-29 2013-02-12 2013-03-09 NA     \n 7 CDISCPILO… 01-701…   1057 NA         NA         NA         NA         NA     \n 8 CDISCPILO… 01-701…   1097 2014-01-01 2014-07-09 2014-01-01 2014-07-09 NA     \n 9 CDISCPILO… 01-701…   1111 2012-09-07 2012-09-17 2012-09-07 2012-09-16 NA     \n10 CDISCPILO… 01-701…   1115 2012-11-30 2013-01-23 2012-11-30 2013-01-23 NA     \n# … with 296 more rows, and 34 more variables: RFPENDTC <dttm>, DTHDTC <date>,\n#   DTHFL <chr>, SITEID <dbl>, AGE <dbl>, AGEU <chr>, SEX <chr>, RACE <chr>,\n#   ETHNIC <chr>, ARMCD <chr>, ARM <chr>, ACTARMCD <chr>, ACTARM <chr>,\n#   COUNTRY <chr>, DMDTC <date>, DMDY <dbl>, TRT01P <chr>, TRT01A <chr>,\n#   TRTSDTM <dttm>, TRTSTMF <chr>, TRTEDTM <dttm>, TRTETMF <chr>,\n#   TRTDURD <dbl>, EOSSTT <chr>, DTHADY <dbl>, LDDTHELD <dbl>, AGEGR1 <chr>,\n#   SAFFL <chr>, RACEGR1 <chr>, REGION1 <lgl>, LDDTHGR1 <chr>, DTH30FL <chr>, …\n\n\n\n\n\n\n\n\nChange order of variables\n\n\n\nWe can use the select() function to reorder the variables in the data-frame. This does not affect the order of rows.\n\nselect(adsl,\n       ARM, \n       USUBJID)\n\n# A tibble: 306 × 2\n   ARM                  USUBJID    \n   <chr>                <chr>      \n 1 Placebo              01-701-1015\n 2 Placebo              01-701-1023\n 3 Xanomeline High Dose 01-701-1028\n 4 Xanomeline Low Dose  01-701-1033\n 5 Xanomeline High Dose 01-701-1034\n 6 Placebo              01-701-1047\n 7 Screen Failure       01-701-1057\n 8 Xanomeline Low Dose  01-701-1097\n 9 Xanomeline Low Dose  01-701-1111\n10 Xanomeline Low Dose  01-701-1115\n# … with 296 more rows\n\n\n\n\n\n\n3.2.2 filter\nThe filter function allows us to look at a subset of observations. As input, the function requires a logical vector and (of course) a data-frame. This time, we first save the reduced (selected) data-frame and use that as the first argument to filter.\n\nselected_data <- select(adsl, \n                        STUDYID, \n                        USUBJID, \n                        ARM, \n                        AGE, \n                        SEX, \n                        RACE)\n\nThe logical vector is generally created within the function call and can use any of the following logic operators:\n<                less than\n<=               less than or equal to\n>                greater than\n>=               greater than or equal to\n==               equal\n!=               not equal\n!x               not x (negation)\nx | y            x OR y\nx & y            x AND y\nx %in% y         logical vector of length x with TRUE if element of x is in y \nWithin filter, we can chain logical vectors by separating them with a comma (,). Lets have a look at women that are 70 and older:\n\nfilter(selected_data,\n       AGE >= 70,\n       SEX == \"F\")\n\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM                    AGE SEX   RACE               \n   <chr>        <chr>       <chr>                <dbl> <chr> <chr>              \n 1 CDISCPILOT01 01-701-1034 Xanomeline High Dose    77 F     WHITE              \n 2 CDISCPILOT01 01-701-1047 Placebo                 85 F     WHITE              \n 3 CDISCPILOT01 01-701-1111 Xanomeline Low Dose     81 F     WHITE              \n 4 CDISCPILOT01 01-701-1133 Xanomeline High Dose    81 F     WHITE              \n 5 CDISCPILOT01 01-701-1146 Xanomeline High Dose    75 F     WHITE              \n 6 CDISCPILOT01 01-701-1153 Placebo                 79 F     WHITE              \n 7 CDISCPILOT01 01-701-1162 Screen Failure          82 F     WHITE              \n 8 CDISCPILOT01 01-701-1181 Xanomeline High Dose    79 F     WHITE              \n 9 CDISCPILOT01 01-701-1192 Xanomeline Low Dose     80 F     WHITE              \n10 CDISCPILOT01 01-701-1203 Placebo                 81 F     BLACK OR AFRICAN A…\n# … with 131 more rows\n\n\nNow we have a reduced data frame with female patients over 70. However, the nested call is not very intuitive to read. If any more functions get added to this code, it becomes even less readable. That is where the pipe operator (%>%) comes in.\n\n\n\n\n\n\npipe\n\n\n\nThe pipe operator let us chain multiple dplyr commands, so we can always forward the previously filtered / selected / arranged dataframe and keep working with it. The pipe operator let’s us write nested function calls in a sequential way. Traditionally, we start a new line after every pipe operator.\n\n\n\n# select, filter, & pipe:\nadsl %>% # This pipe forwards adsl to the select function as its first argument\n  select(STUDYID, \n         USUBJID,\n         ARM, \n         AGE, \n         SEX, \n         RACE) %>% # this pipe forwards the selected variables to the filter function\n  filter(AGE >= 70,\n         SEX == \"F\")\n\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM                    AGE SEX   RACE               \n   <chr>        <chr>       <chr>                <dbl> <chr> <chr>              \n 1 CDISCPILOT01 01-701-1034 Xanomeline High Dose    77 F     WHITE              \n 2 CDISCPILOT01 01-701-1047 Placebo                 85 F     WHITE              \n 3 CDISCPILOT01 01-701-1111 Xanomeline Low Dose     81 F     WHITE              \n 4 CDISCPILOT01 01-701-1133 Xanomeline High Dose    81 F     WHITE              \n 5 CDISCPILOT01 01-701-1146 Xanomeline High Dose    75 F     WHITE              \n 6 CDISCPILOT01 01-701-1153 Placebo                 79 F     WHITE              \n 7 CDISCPILOT01 01-701-1162 Screen Failure          82 F     WHITE              \n 8 CDISCPILOT01 01-701-1181 Xanomeline High Dose    79 F     WHITE              \n 9 CDISCPILOT01 01-701-1192 Xanomeline Low Dose     80 F     WHITE              \n10 CDISCPILOT01 01-701-1203 Placebo                 81 F     BLACK OR AFRICAN A…\n# … with 131 more rows\n\n\nThere is another inline operator which can be very useful within the filter function; %in%. With this operator, we can select rows based on a prespecified vector of values. This can be useful if there are specified values (e.g., specific USUBJID) which we would like to look at.\n\n# we save 4 USUBJID's in a vector:\nlookup_ids <- c(\"01-716-1151\", \"01-710-1443\", \"01-708-1184\", \"01-705-1186\")\n\n\n# and then create a logical vector which returns TRUE for every entry in the \n# USUBJID vector which are represented in the lookup_ids, and else FALSE\nadsl$USUBJID %in% lookup_ids\n\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE\n\n# this approach can be used in the filter function: \nadsl %>% \n  select(STUDYID, USUBJID, ARM, AGE, SEX, RACE) %>% \n  filter(USUBJID %in% lookup_ids)\n\n# A tibble: 4 × 6\n  STUDYID      USUBJID     ARM                   AGE SEX   RACE \n  <chr>        <chr>       <chr>               <dbl> <chr> <chr>\n1 CDISCPILOT01 01-705-1186 Placebo                84 F     WHITE\n2 CDISCPILOT01 01-708-1184 Screen Failure         70 F     WHITE\n3 CDISCPILOT01 01-710-1443 Screen Failure         88 F     WHITE\n4 CDISCPILOT01 01-716-1151 Xanomeline Low Dose    83 F     WHITE\n\n\nNote that within the filter function (and in all major dplyr functions) R looks for the requested variables first within the supplied data-frame and afterwards in the global environment.\n\n\n3.2.3 arrange\nWe can sort the dataframe with the arrange() function. It allows the sorting based on multiple variables. Note that the order of arranging variables determines the sorting hierarchy, so in this example we first order by AGE and\n\n adsl %>% \n  select(STUDYID, USUBJID, ARM, AGE, SEX, RACE) %>% \n  filter(AGE >= 70,\n         SEX == \"F\") %>% \n  arrange(ARM, AGE)\n\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM       AGE SEX   RACE                     \n   <chr>        <chr>       <chr>   <dbl> <chr> <chr>                    \n 1 CDISCPILOT01 01-705-1282 Placebo    70 F     BLACK OR AFRICAN AMERICAN\n 2 CDISCPILOT01 01-704-1260 Placebo    71 F     WHITE                    \n 3 CDISCPILOT01 01-703-1210 Placebo    72 F     WHITE                    \n 4 CDISCPILOT01 01-716-1026 Placebo    73 F     WHITE                    \n 5 CDISCPILOT01 01-718-1150 Placebo    73 F     WHITE                    \n 6 CDISCPILOT01 01-708-1087 Placebo    74 F     WHITE                    \n 7 CDISCPILOT01 01-708-1316 Placebo    74 F     WHITE                    \n 8 CDISCPILOT01 01-709-1001 Placebo    76 F     WHITE                    \n 9 CDISCPILOT01 01-710-1077 Placebo    76 F     WHITE                    \n10 CDISCPILOT01 01-715-1397 Placebo    76 F     WHITE                    \n# … with 131 more rows\n\n\nTo sort by descending order, we can use the helper function desc() within arrange():\n\n adsl %>% \n  select(STUDYID, USUBJID, ARM, AGE, SEX, RACE) %>% \n  filter(AGE >= 70,\n         SEX == \"F\") %>% \n  arrange(ARM, desc(AGE))\n\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM       AGE SEX   RACE \n   <chr>        <chr>       <chr>   <dbl> <chr> <chr>\n 1 CDISCPILOT01 01-710-1083 Placebo    89 F     WHITE\n 2 CDISCPILOT01 01-710-1368 Placebo    88 F     WHITE\n 3 CDISCPILOT01 01-714-1035 Placebo    88 F     WHITE\n 4 CDISCPILOT01 01-701-1387 Placebo    87 F     WHITE\n 5 CDISCPILOT01 01-704-1233 Placebo    87 F     WHITE\n 6 CDISCPILOT01 01-716-1024 Placebo    87 F     WHITE\n 7 CDISCPILOT01 01-705-1349 Placebo    86 F     WHITE\n 8 CDISCPILOT01 01-710-1271 Placebo    86 F     WHITE\n 9 CDISCPILOT01 01-716-1108 Placebo    86 F     WHITE\n10 CDISCPILOT01 01-701-1047 Placebo    85 F     WHITE\n# … with 131 more rows"
  },
  {
    "objectID": "dplyr_exercises.html",
    "href": "dplyr_exercises.html",
    "title": "4  dplyr exercises",
    "section": "",
    "text": "library(\"tidyverse\")\n\n\n# load data\nadsl <- read_csv(\"data/adsl.csv\")"
  },
  {
    "objectID": "dplyr_exercises.html#data-wrangling-with-dplyr",
    "href": "dplyr_exercises.html#data-wrangling-with-dplyr",
    "title": "4  dplyr exercises",
    "section": "4.2 Data wrangling with dplyr",
    "text": "4.2 Data wrangling with dplyr\nLoad the adsl data-frame and select the following variables:\n\nUSUBJID\nARM\nSEX\nAGE\nAGEU\nAGEGR1\nCOUNTRY\nEOSSTT\n\n\n\nShow solution\n# we use starts_with(\"AGE\") because we want to include every AGE variable that is in the original data-frame, instead, we could also list all AGE variables separately.\nadsl %>% \n  select(USUBJID, ARM, SEX, starts_with(\"AGE\"), COUNTRY, EOSSTT)\n\n\n# A tibble: 306 × 8\n   USUBJID     ARM                  SEX     AGE AGEU  AGEGR1 COUNTRY EOSSTT     \n   <chr>       <chr>                <chr> <dbl> <chr> <chr>  <chr>   <chr>      \n 1 01-701-1015 Placebo              F        63 YEARS 18-64  USA     COMPLETED  \n 2 01-701-1023 Placebo              M        64 YEARS 18-64  USA     DISCONTINU…\n 3 01-701-1028 Xanomeline High Dose M        71 YEARS >=65   USA     COMPLETED  \n 4 01-701-1033 Xanomeline Low Dose  M        74 YEARS >=65   USA     DISCONTINU…\n 5 01-701-1034 Xanomeline High Dose F        77 YEARS >=65   USA     COMPLETED  \n 6 01-701-1047 Placebo              F        85 YEARS >=65   USA     DISCONTINU…\n 7 01-701-1057 Screen Failure       F        59 YEARS 18-64  USA     <NA>       \n 8 01-701-1097 Xanomeline Low Dose  M        68 YEARS >=65   USA     COMPLETED  \n 9 01-701-1111 Xanomeline Low Dose  F        81 YEARS >=65   USA     DISCONTINU…\n10 01-701-1115 Xanomeline Low Dose  M        84 YEARS >=65   USA     DISCONTINU…\n# … with 296 more rows\n\n\nOn the selected variables, include only patients in the placebo arm who are 66, 77, 88, or 99 years old.\n\n\nShow solution\n# There are different ways to solve this. The best way to filter the AGE is to create a vector c(66, 77, 88, 99) and then use the %in% operator. The vector can be created in different ways, e.g.: \nage_vec <- c(66, 77, 88, 99)\n# or \nage_vec  <- 6:9 * 11\n# we can then use either the age_vec or the code that created the age_vec directly as a statement in the filter function:\n\n\nadsl %>% \n  select(USUBJID, SEX, ARM, EOSSTT, starts_with(\"AGE\")) %>% \n  filter(ARM == \"Placebo\",\n         AGE %in% c(66, 77, 88, 99))\n\n\n# A tibble: 5 × 7\n  USUBJID     SEX   ARM     EOSSTT         AGE AGEU  AGEGR1\n  <chr>       <chr> <chr>   <chr>        <dbl> <chr> <chr> \n1 01-705-1059 F     Placebo DISCONTINUED    66 YEARS >=65  \n2 01-708-1171 F     Placebo COMPLETED       77 YEARS >=65  \n3 01-710-1368 F     Placebo COMPLETED       88 YEARS >=65  \n4 01-714-1035 F     Placebo COMPLETED       88 YEARS >=65  \n5 01-718-1139 M     Placebo COMPLETED       77 YEARS >=65  \n\n\nFurther include the variable TRTSDTM (datetime of first exposure to treatment) and sort the previous data-frame according to this variable from most recent to least recent first exposure.\n\n\nShow solution\nadsl %>% \n  select(USUBJID, SEX, ARM, EOSSTT, starts_with(\"AGE\"), TRTSDTM) %>% \n  filter(ARM == \"Placebo\",\n         AGE %in% c(66, 77, 88, 99)) %>% \n  arrange(desc(TRTSDTM))\n\n\n# A tibble: 5 × 8\n  USUBJID     SEX   ARM     EOSSTT         AGE AGEU  AGEGR1 TRTSDTM            \n  <chr>       <chr> <chr>   <chr>        <dbl> <chr> <chr>  <dttm>             \n1 01-714-1035 F     Placebo COMPLETED       88 YEARS >=65   2014-04-17 00:00:00\n2 01-710-1368 F     Placebo COMPLETED       88 YEARS >=65   2013-10-23 00:00:00\n3 01-705-1059 F     Placebo DISCONTINUED    66 YEARS >=65   2013-08-05 00:00:00\n4 01-718-1139 M     Placebo COMPLETED       77 YEARS >=65   2013-05-19 00:00:00\n5 01-708-1171 F     Placebo COMPLETED       77 YEARS >=65   2012-12-06 00:00:00"
  },
  {
    "objectID": "mutate.html",
    "href": "mutate.html",
    "title": "5  mutate",
    "section": "",
    "text": "The equivalent of creating a new variables in SAS inside a data step is to use the mutate() function. In the simplest case a static value is assigned to the new column.\n\nadsl <- dm %>% mutate(DATASET = \"ADSL\")\n\nThis will set the value of the new variable DATASET to \"ADSL\" for all records.\n\nadsl %>% select(DATASET)\n\n# A tibble: 306 × 1\n   DATASET\n   <chr>  \n 1 ADSL   \n 2 ADSL   \n 3 ADSL   \n 4 ADSL   \n 5 ADSL   \n 6 ADSL   \n 7 ADSL   \n 8 ADSL   \n 9 ADSL   \n10 ADSL   \n# … with 296 more rows\n\n\nNote that new variables are always appended after existing columns such that DATASET is now the last column of adsl.\n\ncolnames(adsl)\n\n [1] \"STUDYID\"  \"DOMAIN\"   \"USUBJID\"  \"SUBJID\"   \"RFSTDTC\"  \"RFENDTC\" \n [7] \"RFXSTDTC\" \"RFXENDTC\" \"RFICDTC\"  \"RFPENDTC\" \"DTHDTC\"   \"DTHFL\"   \n[13] \"SITEID\"   \"AGE\"      \"AGEU\"     \"SEX\"      \"RACE\"     \"ETHNIC\"  \n[19] \"ARMCD\"    \"ARM\"      \"ACTARMCD\" \"ACTARM\"   \"COUNTRY\"  \"DMDTC\"   \n[25] \"DMDY\"     \"DATASET\" \n\n\nAssigning the value of an existing column to a new column is the same as in SAS. The new column name goes to the left of = and the existing column to the right.\n\nadsl <- adsl %>% mutate(TRT01P = ARM)\nadsl %>% select(ARM, TRT01P)\n\n# A tibble: 306 × 2\n   ARM                  TRT01P              \n   <chr>                <chr>               \n 1 Placebo              Placebo             \n 2 Placebo              Placebo             \n 3 Xanomeline High Dose Xanomeline High Dose\n 4 Xanomeline Low Dose  Xanomeline Low Dose \n 5 Xanomeline High Dose Xanomeline High Dose\n 6 Placebo              Placebo             \n 7 Screen Failure       Screen Failure      \n 8 Xanomeline Low Dose  Xanomeline Low Dose \n 9 Xanomeline Low Dose  Xanomeline Low Dose \n10 Xanomeline Low Dose  Xanomeline Low Dose \n# … with 296 more rows\n\n\nIn most cases new variables are created by applying functions on existing variables to somehow transform them.\n\nadsl <- adsl %>% mutate(RFSTDT = ymd(RFSTDTC))\n\nYou can create multiple new variables inside mutate() similar to how you would do it inside a data step.\n\nadae <- ae %>% mutate(\n  ASTDT = ymd(AESTDTC),\n  ASTDY = ASTDT - TRTSDT + 1\n)\nadae %>% select(AESTDTC, ASTDT, TRTSDT, ASTDY)\n\n# A tibble: 1,191 × 4\n   AESTDTC    ASTDT      TRTSDT     ASTDY  \n   <chr>      <date>     <date>     <drtn> \n 1 2014-01-03 2014-01-03 2014-01-02  2 days\n 2 2014-01-03 2014-01-03 2014-01-02  2 days\n 3 2014-01-09 2014-01-09 2014-01-02  8 days\n 4 2012-08-26 2012-08-26 2012-08-05 22 days\n 5 2012-08-07 2012-08-07 2012-08-05  3 days\n 6 2012-08-07 2012-08-07 2012-08-05  3 days\n 7 2012-08-07 2012-08-07 2012-08-05  3 days\n 8 2013-07-21 2013-07-21 2013-07-19  3 days\n 9 2013-08-08 2013-08-08 2013-07-19 21 days\n10 2014-08-27 2014-08-27 2014-07-01 58 days\n# … with 1,181 more rows\n\n\nJust like in SAS you can use conditional logic to assign different values to a new variable depending on which value another variable has using if_else().\n\nadae %>%\n  mutate(ASTDY = if_else(ASTDT <= TRTSDT, ASTDT - TRTSDT, ASTDT - TRTSDT + 1)) %>% \n  select(USUBJID, TRTSDT, ASTDT, ASTDY)\n\n# A tibble: 1,191 × 4\n   USUBJID     TRTSDT     ASTDT      ASTDY  \n   <chr>       <date>     <date>     <drtn> \n 1 01-701-1015 2014-01-02 2014-01-03  2 days\n 2 01-701-1015 2014-01-02 2014-01-03  2 days\n 3 01-701-1015 2014-01-02 2014-01-09  8 days\n 4 01-701-1023 2012-08-05 2012-08-26 22 days\n 5 01-701-1023 2012-08-05 2012-08-07  3 days\n 6 01-701-1023 2012-08-05 2012-08-07  3 days\n 7 01-701-1023 2012-08-05 2012-08-07  3 days\n 8 01-701-1028 2013-07-19 2013-07-21  3 days\n 9 01-701-1028 2013-07-19 2013-08-08 21 days\n10 01-701-1034 2014-07-01 2014-08-27 58 days\n# … with 1,181 more rows\n\n\nAt this point let’s make a small excursion to cover how R handles missing values, i.e. NA, when using conditional logic. Unlike in SAS where missing numbers are the smallest possible values such that . < 10 is true, in R any comparison involving NA returns NA as a result.\n\nNA < 9\n\n[1] NA\n\nNA == 0\n\n[1] NA\n\n\nThis is the same when using if_else().\n\nadsl$AGE[1] <- NA\nadsl %>% \n  mutate(AGEGR = if_else(AGE >= 65, \"Elderly\", \"Adult\")) %>% \n  select(USUBJID, AGE, AGEGR)\n\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR  \n   <chr>       <int> <chr>  \n 1 01-701-1015    NA <NA>   \n 2 01-701-1023    64 Adult  \n 3 01-701-1028    71 Elderly\n 4 01-701-1033    74 Elderly\n 5 01-701-1034    77 Elderly\n 6 01-701-1047    85 Elderly\n 7 01-701-1057    59 Adult  \n 8 01-701-1097    68 Elderly\n 9 01-701-1111    81 Elderly\n10 01-701-1115    84 Elderly\n# … with 296 more rows\n\n\nTo check whether a value is missing use the is.na() function.\n\nis.na(NA)\n\n[1] TRUE\n\nis.na(\"NA\")\n\n[1] FALSE\n\n\nFinally, it’s noteworthy that is are actually different types on NAs in R. We’ll make use of them next.\n\nTypes of `NA` in R\n\n\nType\nExample\nMissing Value\n\n\n\n\ncharacter\n\"Brazil\"\nNA_character_\n\n\ndouble\n2.51\nNA_real_\n\n\ninteger\n1L\nNA_integer_\n\n\nlogical\nFALSE\nNA\n\n\n\nIf the logic is more complex than a simple if_else() than use case_when() instead.\n\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      TRUE ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA >=65  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n\n\nThe final condition TRUE is the is a catch all term and must be used with some caution. Notice what happened to the AGE of the first subject whose value we set to NA above.\nTo mitigate this you should either explicitly handle missing values as a separate condition or be explicit for all cases. The former would look something like this.\n\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      is.na(AGE) ~ NA_character_,\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      TRUE ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA <NA>  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n\n\nAnd the latter like this.\n\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      AGE >= 65 ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA <NA>  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n\n\nFinally, note that when a value does not match any of the conditions given which may be the case when not using a final TRUE then it is assigned NA.\n\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA <NA>  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 <NA>  \n 4 01-701-1033    74 <NA>  \n 5 01-701-1034    77 <NA>  \n 6 01-701-1047    85 <NA>  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 <NA>  \n 9 01-701-1111    81 <NA>  \n10 01-701-1115    84 <NA>  \n# … with 296 more rows"
  },
  {
    "objectID": "mutate_exercises.html",
    "href": "mutate_exercises.html",
    "title": "6  mutate exercises",
    "section": "",
    "text": "library(dplyr)\nlibrary(lubridate)\ndm <- readRDS(\"data/dm.rds\")\nae <- readRDS(\"data/ae.rds\")"
  },
  {
    "objectID": "mutate_exercises.html#exercise-1",
    "href": "mutate_exercises.html#exercise-1",
    "title": "6  mutate exercises",
    "section": "6.2 Exercise 1",
    "text": "6.2 Exercise 1\nA treatment emergent adverse event is defined as an adverse event whose start date is on or after the treatment start date (TRTSDT) and at the latest starts 7 days after the treatment end date (TRTEDT). Given this definition calculate TRTEMFL.\nHint: Turn the --DTC variables into proper dates first using the ymd() function.\n\n\nShow solution\nae %>% \n  mutate(\n    ASTDT = ymd(AESTDTC),\n    AENDT = ymd(AEENDTC),\n    TRTEMFL = if_else(ASTDT >= TRTSDT & ASTDT <= TRTEDT + 7, \"Y\", NA_character_)\n  ) %>% \n  select(USUBJID, ASTDT, AENDT, TRTSDT, TRTEDT, TRTEMFL)\n\n\nWarning: 19 failed to parse.\n\n\n# A tibble: 1,191 × 6\n   USUBJID     ASTDT      AENDT      TRTSDT     TRTEDT     TRTEMFL\n   <chr>       <date>     <date>     <date>     <date>     <chr>  \n 1 01-701-1015 2014-01-03 NA         2014-01-02 2014-07-02 Y      \n 2 01-701-1015 2014-01-03 NA         2014-01-02 2014-07-02 Y      \n 3 01-701-1015 2014-01-09 2014-01-11 2014-01-02 2014-07-02 Y      \n 4 01-701-1023 2012-08-26 NA         2012-08-05 2012-09-01 Y      \n 5 01-701-1023 2012-08-07 2012-08-30 2012-08-05 2012-09-01 Y      \n 6 01-701-1023 2012-08-07 NA         2012-08-05 2012-09-01 Y      \n 7 01-701-1023 2012-08-07 2012-08-30 2012-08-05 2012-09-01 Y      \n 8 01-701-1028 2013-07-21 NA         2013-07-19 2014-01-14 Y      \n 9 01-701-1028 2013-08-08 NA         2013-07-19 2014-01-14 Y      \n10 01-701-1034 2014-08-27 NA         2014-07-01 2014-12-30 Y      \n# … with 1,181 more rows"
  },
  {
    "objectID": "mutate_exercises.html#exercise-2",
    "href": "mutate_exercises.html#exercise-2",
    "title": "6  mutate exercises",
    "section": "6.3 Exercise 2",
    "text": "6.3 Exercise 2\nCreate a new variable REGION1 based upon COUTRY as shown in the table below.\n\n\n\nCountries\nRegion\n\n\n\n\nMexico, USA, Canada\nNorth America\n\n\nSpain, Greece, Germany, Switzerland\nEurope\n\n\nChina, Japan\nAsia\n\n\n\n\n\nShow solution\ndm %>% \n  mutate(\n    REGION1 = case_when(\n      COUNTRY %in% c(\"Mexico\", \"USA\", \"Canada\") ~ \"North America\",\n      COUNTRY %in% c(\"Spain\", \"Greece\", \"Germany\", \"Switzerland\") ~ \"Europe\",\n      COUNTRY %in% c(\"China\", \"Japan\") ~ \"Asia\"\n    )\n  ) %>% \n  select(USUBJID, COUNTRY, REGION1)\n\n\n# A tibble: 306 × 3\n   USUBJID     COUNTRY REGION1      \n   <chr>       <chr>   <chr>        \n 1 01-701-1015 USA     North America\n 2 01-701-1023 USA     North America\n 3 01-701-1028 USA     North America\n 4 01-701-1033 USA     North America\n 5 01-701-1034 USA     North America\n 6 01-701-1047 USA     North America\n 7 01-701-1057 USA     North America\n 8 01-701-1097 USA     North America\n 9 01-701-1111 USA     North America\n10 01-701-1115 USA     North America\n# … with 296 more rows"
  },
  {
    "objectID": "summarizing_data.html",
    "href": "summarizing_data.html",
    "title": "7  summarizing data",
    "section": "",
    "text": "While mutate() adds a new variable for all existing records to a dataset, summarize() aggregates one or more columns of a dataset thereby “collapsing” it. In the simplest case a single variable is aggregated using a summary function such as mean().\n\ndm %>% \n  summarize(avg_age = mean(AGE, na.rm = TRUE))\n\n# A tibble: 1 × 1\n  avg_age\n    <dbl>\n1    75.1\n\n\nJust like you can create multiple variables inside a single call to mutate() you can aggregate multiple variables (or the same variable with multiple summary functions) inside summarize().\n\ndm %>% \n  summarize(\n    avg_age = mean(AGE, na.rm = TRUE),\n    median_age = median(AGE, na.rm = TRUE)\n  )\n\n# A tibble: 1 × 2\n  avg_age median_age\n    <dbl>      <dbl>\n1    75.1         77\n\n\nSo far we aggregated only numeric variables. Another useful aggregation is counting the number of records.\n\ndm %>% \n  summarize(N = n())\n\n# A tibble: 1 × 1\n      N\n  <int>\n1   306\n\n\nThis becomes quite powerful when combining summarize() with group_by(). This should look rather familiar to you if you every aggregated data using proc sql.\n\ndm %>% \n  group_by(COUNTRY) %>% \n  summarize(n = n()) %>% \n  ungroup()\n\n# A tibble: 9 × 2\n  COUNTRY         n\n  <chr>       <int>\n1 Canada         86\n2 China          55\n3 Germany        49\n4 Greece         13\n5 Japan          12\n6 Mexico          5\n7 Spain           6\n8 Switzerland     9\n9 USA            71\n\n\nNote that it is best practice to ungroup() the dataset after you aggregated it. Failing to do so can lead to some rather bogus error when continuing to manipulate the aggregated dataset, e.g. using mutate().\ngroup_by() and summarize() can be used with numeric variables as well. In addition one can group by more than a single variable.\n\ndm %>% \n  group_by(ARM, COUNTRY) %>% \n  summarize(avg_age = mean(AGE, na.rm = TRUE)) %>% \n  ungroup()\n\n# A tibble: 32 × 3\n   ARM            COUNTRY     avg_age\n   <chr>          <chr>         <dbl>\n 1 Placebo        Canada         79.2\n 2 Placebo        China          70.5\n 3 Placebo        Germany        75.2\n 4 Placebo        Greece         75.8\n 5 Placebo        Japan          70  \n 6 Placebo        Mexico         65  \n 7 Placebo        Spain          83  \n 8 Placebo        Switzerland    69.3\n 9 Placebo        USA            74.9\n10 Screen Failure Canada         75.1\n# … with 22 more rows"
  },
  {
    "objectID": "summarizing_data_exercises.html",
    "href": "summarizing_data_exercises.html",
    "title": "8  summarizing data exercises",
    "section": "",
    "text": "library(dplyr)\ndm <- readRDS(\"data/dm.rds\")\nae <- readRDS(\"data/ae.rds\")"
  },
  {
    "objectID": "summarizing_data_exercises.html#exercise-1",
    "href": "summarizing_data_exercises.html#exercise-1",
    "title": "8  summarizing data exercises",
    "section": "8.2 Exercise 1",
    "text": "8.2 Exercise 1\nCount the number of overall adverse events per subject and sort the output such that the subject with the highest overall number of adverse events appears first.\n\n\nShow solution\nae %>% \n  group_by(USUBJID) %>% \n  summarise(n_ae = n()) %>% \n  arrange(desc(n_ae))\n\n\n# A tibble: 225 × 2\n   USUBJID      n_ae\n   <chr>       <int>\n 1 01-701-1302    23\n 2 01-717-1004    19\n 3 01-704-1266    16\n 4 01-709-1029    16\n 5 01-718-1427    16\n 6 01-701-1192    15\n 7 01-701-1275    15\n 8 01-709-1309    15\n 9 01-713-1179    15\n10 01-711-1143    14\n# … with 215 more rows"
  },
  {
    "objectID": "summarizing_data_exercises.html#exercise-2",
    "href": "summarizing_data_exercises.html#exercise-2",
    "title": "8  summarizing data exercises",
    "section": "8.3 Exercise 2",
    "text": "8.3 Exercise 2\nCount the overall number of serious adverse events per treatment arm (ACTARM).\n\n\nShow solution\nae %>% \n  filter(AESER == \"Y\") %>% \n  group_by(ACTARM) %>% \n  summarise(n = n())\n\n\n# A tibble: 2 × 2\n  ACTARM                   n\n  <chr>                <int>\n1 Xanomeline High Dose     1\n2 Xanomeline Low Dose      2"
  },
  {
    "objectID": "summarizing_data_exercises.html#exercise-3",
    "href": "summarizing_data_exercises.html#exercise-3",
    "title": "8  summarizing data exercises",
    "section": "8.4 Exercise 3",
    "text": "8.4 Exercise 3\nFind the lowest and highest AGE per treatment arm.\n\n\nShow solution\ndm %>% \n  group_by(ARM) %>% \n  summarise(youngest = min(AGE, na.rm = TRUE), oldest = max(AGE, na.rm = TRUE))\n\n\n# A tibble: 4 × 3\n  ARM                  youngest oldest\n  <chr>                   <int>  <int>\n1 Placebo                    52     89\n2 Screen Failure             50     89\n3 Xanomeline High Dose       56     88\n4 Xanomeline Low Dose        51     88"
  },
  {
    "objectID": "tidyr.html",
    "href": "tidyr.html",
    "title": "9  tidyr",
    "section": "",
    "text": "As we know, data can often be represented in several ways. Multiple observations of a variable can be organized by rows or by columns.\nTable A.\n\n\n\nID\nPre\nPost\n\n\n\n\nx\n1\n2\n\n\ny\n3\n4\n\n\n\nTable B.\n\n\n\nID\nTime\nValue\n\n\n\n\nx\nPre\n1\n\n\nx\nPost\n2\n\n\ny\nPre\n3\n\n\ny\nPost\n4\n\n\n\nWhen observations are spread along a row as multiple columns, we refer to the data as being in “wide” format (See Table A). When observations are spread along a column as multiple rows, we refer to the data as being in “long” format (See Table B). SDTM data for the most part generally adheres to the “long” structure, but as programmers we need to know how to work with both to suit our needs.\nTo get the desired shape of data, there are two useful functions from the tidyr package to make this transformation, aptly named: pivot_longer() and pivot_wider() . These can be seen as the R-equivalent of proc transpose in SAS.\n\n\n\n\nlibrary(dplyr)\nlibrary(tidyr)\nsuppdm <- readRDS(\"data/suppdm.rds\") %>%\n  select(USUBJID, QNAM, QVAL)\n\nhead(suppdm, 10)\n\n# A tibble: 10 × 3\n   USUBJID     QNAM     QVAL \n   <chr>       <chr>    <chr>\n 1 01-701-1015 COMPLT16 Y    \n 2 01-701-1015 COMPLT24 Y    \n 3 01-701-1015 COMPLT8  Y    \n 4 01-701-1015 EFFICACY Y    \n 5 01-701-1015 ITT      Y    \n 6 01-701-1015 SAFETY   Y    \n 7 01-701-1023 EFFICACY Y    \n 8 01-701-1023 ITT      Y    \n 9 01-701-1023 SAFETY   Y    \n10 01-701-1028 COMPLT16 Y    \n\n\nAs we see here, in our SUPPDM domain, the data is currently in the “long” format. If we wanted to transform the dataset such that each of the unique values of QNAM was their own column, we are looking to transpose the data from “long” to “wide”. In this case, we use pivot_wider().\n\nsuppdm_wide <- suppdm %>% \n  pivot_wider(\n    names_from = \"QNAM\", # assign column names based on QNAM\n    values_from = \"QVAL\" # retrieve values from QVAL\n  )\nsuppdm_wide\n\n# A tibble: 254 × 7\n   USUBJID     COMPLT16 COMPLT24 COMPLT8 EFFICACY ITT   SAFETY\n   <chr>       <chr>    <chr>    <chr>   <chr>    <chr> <chr> \n 1 01-701-1015 Y        Y        Y       Y        Y     Y     \n 2 01-701-1023 <NA>     <NA>     <NA>    Y        Y     Y     \n 3 01-701-1028 Y        Y        Y       Y        Y     Y     \n 4 01-701-1033 <NA>     <NA>     <NA>    Y        Y     Y     \n 5 01-701-1034 Y        Y        Y       Y        Y     Y     \n 6 01-701-1047 <NA>     <NA>     <NA>    Y        Y     Y     \n 7 01-701-1097 Y        Y        Y       Y        Y     Y     \n 8 01-701-1111 <NA>     <NA>     <NA>    Y        Y     Y     \n 9 01-701-1115 <NA>     <NA>     Y       Y        Y     Y     \n10 01-701-1118 Y        Y        Y       Y        Y     Y     \n# … with 244 more rows\n\n\nVoila! This “wide” dataset may prove useful for joins (to be discussed later). But for now, let’s pretend that this “wide” format is how our original data came to us in. If we wanted to take these respective flagging columns and turn them into a “long” format, we use pivot_longer().\n\nsuppdm_long <- suppdm_wide %>% \n  pivot_longer(\n    cols = c(\"COMPLT16\", \"COMPLT24\", \"COMPLT8\", \"EFFICACY\", \"ITT\", \"SAFETY\"), \n    names_to = \"QNAM\",\n    values_to = \"QVAL\"\n  )\nsuppdm_long\n\n# A tibble: 1,524 × 3\n   USUBJID     QNAM     QVAL \n   <chr>       <chr>    <chr>\n 1 01-701-1015 COMPLT16 Y    \n 2 01-701-1015 COMPLT24 Y    \n 3 01-701-1015 COMPLT8  Y    \n 4 01-701-1015 EFFICACY Y    \n 5 01-701-1015 ITT      Y    \n 6 01-701-1015 SAFETY   Y    \n 7 01-701-1023 COMPLT16 <NA> \n 8 01-701-1023 COMPLT24 <NA> \n 9 01-701-1023 COMPLT8  <NA> \n10 01-701-1023 EFFICACY Y    \n# … with 1,514 more rows\n\n\nAs you can see, as we pivoted back, we didn’t come up with an exact duplicate of our original suppdm dataframe. This is because the default of pivot_longer() is not to drop NA values, which can be modified with the values_drop_na function input, just one of the many powerful additional function inputs from both of these pivoting functions. pivot_wider() and pivot_longer() were designed to handle a variety of situations when transposing data in the most flexible of ways.\n\nsuppdm_long <- suppdm_wide %>% \n  pivot_longer(\n    cols = c(\"COMPLT16\", \"COMPLT24\", \"COMPLT8\", \"EFFICACY\", \"ITT\", \"SAFETY\"), \n    names_to = \"flag\",\n    values_to = \"flag_value\",\n    values_drop_na = TRUE\n  )\nsuppdm_long\n\n# A tibble: 1,197 × 3\n   USUBJID     flag     flag_value\n   <chr>       <chr>    <chr>     \n 1 01-701-1015 COMPLT16 Y         \n 2 01-701-1015 COMPLT24 Y         \n 3 01-701-1015 COMPLT8  Y         \n 4 01-701-1015 EFFICACY Y         \n 5 01-701-1015 ITT      Y         \n 6 01-701-1015 SAFETY   Y         \n 7 01-701-1023 EFFICACY Y         \n 8 01-701-1023 ITT      Y         \n 9 01-701-1023 SAFETY   Y         \n10 01-701-1028 COMPLT16 Y         \n# … with 1,187 more rows\n\n\nBonus Trick: The names_to/values_to function arguments can prove to be helpful as a renaming step during the data cleaning process too!"
  },
  {
    "objectID": "tidyr.html#relational-data-joins",
    "href": "tidyr.html#relational-data-joins",
    "title": "9  tidyr",
    "section": "9.2 Relational Data (Joins)",
    "text": "9.2 Relational Data (Joins)\nWhen a pair of tables need to be joined together, we have a variety of functions that can achieve such a task:\n\nleft_join()\nright_join()\nfull_join()\ninner_join()\n\nThe use of these functions is very similar to proc sql in SAS. left_join() will cover most of use cases and is demonstrated below:\n\ndm <- admiral.test::admiral_dm %>% \n  select(STUDYID, USUBJID, AGE, ARM)\n\ndm_suppdm <- dm %>% \n  left_join(suppdm_wide, by = \"USUBJID\")\n\nhead(dm_suppdm)\n\n# A tibble: 6 × 10\n  STUDYID      USUBJID    AGE ARM   COMPL…¹ COMPL…² COMPLT8 EFFIC…³ ITT   SAFETY\n  <chr>        <chr>    <dbl> <chr> <chr>   <chr>   <chr>   <chr>   <chr> <chr> \n1 CDISCPILOT01 01-701-…    63 Plac… Y       Y       Y       Y       Y     Y     \n2 CDISCPILOT01 01-701-…    64 Plac… <NA>    <NA>    <NA>    Y       Y     Y     \n3 CDISCPILOT01 01-701-…    71 Xano… Y       Y       Y       Y       Y     Y     \n4 CDISCPILOT01 01-701-…    74 Xano… <NA>    <NA>    <NA>    Y       Y     Y     \n5 CDISCPILOT01 01-701-…    77 Xano… Y       Y       Y       Y       Y     Y     \n6 CDISCPILOT01 01-701-…    85 Plac… <NA>    <NA>    <NA>    Y       Y     Y     \n# … with abbreviated variable names ¹​COMPLT16, ²​COMPLT24, ³​EFFICACY\n\n\nThe join can also be completed with different column names as long as you define the join-key relationship, demonstrated below:\n\ndummy1 <- data.frame(\n  STUDYID = c(\"TRIALX\", \"TRIALX\"),\n  USUBJID = c(\"1001\", \"1002\"),\n  AGE = c(18, 22)\n)\n\ndummy2 <- data.frame(\n  STUDYID = c(\"TRIALX\", \"TRIALX\"),\n  SUBJECT = c(\"1001\", \"1002\"),\n  SEX = c(\"M\", \"F\")\n)\n\ndummy3 <- dummy1 %>% \n  left_join(dummy2, by = c(\"STUDYID\" = \"STUDYID\", \"USUBJID\" = \"SUBJECT\"))\n\nhead(dummy3)\n\n  STUDYID USUBJID AGE SEX\n1  TRIALX    1001  18   M\n2  TRIALX    1002  22   F"
  },
  {
    "objectID": "tidyr_exercises.html",
    "href": "tidyr_exercises.html",
    "title": "10  tidyr exercises",
    "section": "",
    "text": "library(tidyverse)\nlibrary(dplyr)\nlibrary(tidyr)\n\n# load data\nex <- readRDS(\"data/ex.rds\") \ndm <- readRDS(\"data/dm.rds\") \nds <- readRDS(\"data/ds.rds\") \nsuppds <- readRDS(\"data/suppds.rds\")"
  },
  {
    "objectID": "tidyr_exercises.html#pivoting-with-tidyr",
    "href": "tidyr_exercises.html#pivoting-with-tidyr",
    "title": "10  tidyr exercises",
    "section": "10.2 Pivoting with tidyr",
    "text": "10.2 Pivoting with tidyr\nLoad the ex data-frame from admiral_ex and select the following variables:\n\nUSUBJID\nEXTRT\nVISIT\nEXSTDTC\n\n\n\nShow solution\nex %>% \n  select(USUBJID, EXTRT, VISIT, EXSTDTC)\n\n\n# A tibble: 591 × 4\n   USUBJID     EXTRT      VISIT    EXSTDTC   \n   <chr>       <chr>      <chr>    <chr>     \n 1 01-701-1015 PLACEBO    BASELINE 2014-01-02\n 2 01-701-1015 PLACEBO    WEEK 2   2014-01-17\n 3 01-701-1015 PLACEBO    WEEK 24  2014-06-19\n 4 01-701-1023 PLACEBO    BASELINE 2012-08-05\n 5 01-701-1023 PLACEBO    WEEK 2   2012-08-28\n 6 01-701-1028 XANOMELINE BASELINE 2013-07-19\n 7 01-701-1028 XANOMELINE WEEK 2   2013-08-02\n 8 01-701-1028 XANOMELINE WEEK 24  2014-01-07\n 9 01-701-1033 XANOMELINE BASELINE 2014-03-18\n10 01-701-1034 XANOMELINE BASELINE 2014-07-01\n# … with 581 more rows\n\n\nUsing pivot_wider() create a table that would shaped this way\n\n\n\nUSUBJID\nEXTRT\nBASELINE\nWEEK 2\nWEEK 24\n\n\n\n\n…\n…\n…\n…\n…\n\n\n\n\n\nShow solution\nex %>% \n  select(USUBJID, EXTRT, VISIT, EXSTDTC) %>% \n  pivot_wider(names_from = \"VISIT\", values_from = \"EXSTDTC\")\n\n\n# A tibble: 254 × 5\n   USUBJID     EXTRT      BASELINE   `WEEK 2`   `WEEK 24` \n   <chr>       <chr>      <chr>      <chr>      <chr>     \n 1 01-701-1015 PLACEBO    2014-01-02 2014-01-17 2014-06-19\n 2 01-701-1023 PLACEBO    2012-08-05 2012-08-28 <NA>      \n 3 01-701-1028 XANOMELINE 2013-07-19 2013-08-02 2014-01-07\n 4 01-701-1033 XANOMELINE 2014-03-18 <NA>       <NA>      \n 5 01-701-1034 XANOMELINE 2014-07-01 2014-07-16 2014-12-18\n 6 01-701-1047 PLACEBO    2013-02-12 2013-02-26 <NA>      \n 7 01-701-1097 XANOMELINE 2014-01-01 2014-01-16 2014-06-19\n 8 01-701-1111 XANOMELINE 2012-09-07 <NA>       <NA>      \n 9 01-701-1115 XANOMELINE 2012-11-30 2012-12-14 <NA>      \n10 01-701-1118 PLACEBO    2014-03-12 2014-03-27 2014-08-28\n# … with 244 more rows\n\n\nLoad the dm data-frame from admiral_dm and select the following variables:\n\nUSUBJID\nRACE\nSEX\n\n\n\nShow solution\ndm %>% \n  select(USUBJID, RACE, SEX)\n\n\n# A tibble: 306 × 3\n   USUBJID     RACE  SEX  \n   <chr>       <chr> <chr>\n 1 01-701-1015 WHITE F    \n 2 01-701-1023 WHITE M    \n 3 01-701-1028 WHITE M    \n 4 01-701-1033 WHITE M    \n 5 01-701-1034 WHITE F    \n 6 01-701-1047 WHITE F    \n 7 01-701-1057 WHITE F    \n 8 01-701-1097 WHITE M    \n 9 01-701-1111 WHITE F    \n10 01-701-1115 WHITE M    \n# … with 296 more rows\n\n\nUsing pivot_longer() create a table that would shaped this way\n\n\n\nUSUBJID\nVAR\nVAL\n\n\n\n\n1001\nRACE\nWHITE\n\n\n1001\nSEX\nM\n\n\n\n\n\nShow solution\ndm %>% \n  select(USUBJID, RACE, SEX) %>% \n  pivot_longer(cols = c(RACE, SEX),\n               names_to = \"VAR\",\n               values_to = \"VAL\")\n\n\n# A tibble: 612 × 3\n   USUBJID     VAR   VAL  \n   <chr>       <chr> <chr>\n 1 01-701-1015 RACE  WHITE\n 2 01-701-1015 SEX   F    \n 3 01-701-1023 RACE  WHITE\n 4 01-701-1023 SEX   M    \n 5 01-701-1028 RACE  WHITE\n 6 01-701-1028 SEX   M    \n 7 01-701-1033 RACE  WHITE\n 8 01-701-1033 SEX   M    \n 9 01-701-1034 RACE  WHITE\n10 01-701-1034 SEX   F    \n# … with 602 more rows"
  },
  {
    "objectID": "tidyr_exercises.html#joining-using-dplyr",
    "href": "tidyr_exercises.html#joining-using-dplyr",
    "title": "10  tidyr exercises",
    "section": "10.3 Joining using dplyr",
    "text": "10.3 Joining using dplyr\nLoad the ds data-frame from admiral_ds and suppds data-frame from admiral_suppds. Prior to joining the two datasets together, we may need to do some cleaning of the data on suppds.\n\nFilter IDVAR for \"DSSEQ\"\nMutate IDVARVAL from type character to type numeric.\nSelect USUBJID IDVARVAL QNAM QLABEL QVAL\n\n\n\nShow solution\nsuppds <- suppds %>% \n  filter(IDVAR == \"DSSEQ\") %>% \n  mutate(IDVARVAL = as.numeric(IDVARVAL)) %>% \n  select(USUBJID, IDVARVAL, QNAM, QLABEL, QVAL)\n\nsuppds\n\n\n# A tibble: 3 × 5\n  USUBJID     IDVARVAL QNAM    QLABEL                          QVAL \n  <chr>          <dbl> <chr>   <chr>                           <chr>\n1 01-703-1175        2 ENTCRIT PROTOCOL ENTRY CRITERIA NOT MET 16   \n2 01-705-1382        2 ENTCRIT PROTOCOL ENTRY CRITERIA NOT MET 25   \n3 01-708-1372        3 ENTCRIT PROTOCOL ENTRY CRITERIA NOT MET 16   \n\n\nJoin the two tables together using USUBJID and DSSEQ as the key joining variables.\n\n\nShow solution\nds %>% \n  left_join(suppds, by = c(\"USUBJID\" = \"USUBJID\", \"DSSEQ\" = \"IDVARVAL\"))\n\n\n# A tibble: 850 × 16\n   STUDYID  DOMAIN USUBJID DSSEQ DSSPID DSTERM DSDECOD DSCAT VISIT…¹ VISIT DSDTC\n   <chr>    <chr>  <chr>   <dbl> <chr>  <chr>  <chr>   <chr>   <dbl> <chr> <chr>\n 1 CDISCPI… DS     01-701…     1 <NA>   RANDO… RANDOM… PROT…       3 BASE… 2014…\n 2 CDISCPI… DS     01-701…     2 <NA>   PROTO… COMPLE… DISP…      13 WEEK… 2014…\n 3 CDISCPI… DS     01-701…     3 <NA>   FINAL… FINAL … OTHE…      13 WEEK… 2014…\n 4 CDISCPI… DS     01-701…     1 <NA>   RANDO… RANDOM… PROT…       3 BASE… 2012…\n 5 CDISCPI… DS     01-701…     2 24     ADVER… ADVERS… DISP…       5 WEEK… 2012…\n 6 CDISCPI… DS     01-701…     3 <NA>   FINAL… FINAL … OTHE…       5 WEEK… 2012…\n 7 CDISCPI… DS     01-701…     4 <NA>   FINAL… FINAL … OTHE…     201 RETR… 2013…\n 8 CDISCPI… DS     01-701…     1 <NA>   RANDO… RANDOM… PROT…       3 BASE… 2013…\n 9 CDISCPI… DS     01-701…     2 <NA>   PROTO… COMPLE… DISP…      13 WEEK… 2014…\n10 CDISCPI… DS     01-701…     3 <NA>   FINAL… FINAL … OTHE…      13 WEEK… 2014…\n# … with 840 more rows, 5 more variables: DSSTDTC <chr>, DSSTDY <dbl>,\n#   QNAM <chr>, QLABEL <chr>, QVAL <chr>, and abbreviated variable name\n#   ¹​VISITNUM"
  }
]