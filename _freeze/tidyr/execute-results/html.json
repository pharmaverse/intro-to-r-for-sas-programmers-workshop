{
  "hash": "5c49f75f4ca7aa6a3edda9306e98de08",
  "result": {
    "markdown": "---\ntitle: \"tidyr\"\nauthor: \"Zelos\"\nformat: html\neditor: visual\n---\n\n\n# Transposing Data\n\n## Some Context\n\nAs we know, data can often be represented in several ways. Multiple observations of a variable can be organized by rows or by columns.\n\nTable A.\n\n| ID  | Pre | Post |\n|-----|-----|------|\n| x   | 1   | 2    |\n| y   | 3   | 4    |\n\nTable B.\n\n| ID  | Time | Value |\n|-----|------|-------|\n| x   | Pre  | 1     |\n| x   | Post | 2     |\n| y   | Pre  | 3     |\n| y   | Post | 4     |\n\nWhen observations are spread along a row as multiple columns, we refer to the data as being in \"wide\" format (See Table A). When observations are spread along a column as multiple rows, we refer to the data as being in \"long\" format (See Table B). SDTM data for the most part generally adheres to the \"long\" structure, but as programmers we need to know how to work with both to suit our needs.\n\nTo get the desired shape of data, there are two useful functions from the `tidyr` package to make this transformation, aptly named: `pivot_longer()` and `pivot_wider()` . These can be seen as the R-equivalent of `proc transpose` in SAS.\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(admiral)\nlibrary(admiral.test)\nlibrary(dplyr)\nlibrary(tidyr)\n\nsuppdm <- admiral.test::admiral_suppdm %>%\n  select(USUBJID, QNAM, QVAL)\n\nhead(suppdm, 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 3\n   USUBJID     QNAM     QVAL \n   <chr>       <chr>    <chr>\n 1 01-701-1015 COMPLT16 Y    \n 2 01-701-1015 COMPLT24 Y    \n 3 01-701-1015 COMPLT8  Y    \n 4 01-701-1015 EFFICACY Y    \n 5 01-701-1015 ITT      Y    \n 6 01-701-1015 SAFETY   Y    \n 7 01-701-1023 EFFICACY Y    \n 8 01-701-1023 ITT      Y    \n 9 01-701-1023 SAFETY   Y    \n10 01-701-1028 COMPLT16 Y    \n```\n:::\n:::\n\n\nAs we see here, in our `SUPPDM` domain, the data is currently in the \"long\" format. If we wanted to transform the dataset such that each of the unique values of `QNAM` was their own column, we are looking to transpose the data from \"long\" to \"wide\". In this case, we use `pivot_wider()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppdm_wide <- suppdm %>% \n  pivot_wider(names_from = \"QNAM\", # assign column names based on QNAM\n              values_from = \"QVAL\") # retrieve values from QVAL\nsuppdm_wide\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 254 × 7\n   USUBJID     COMPLT16 COMPLT24 COMPLT8 EFFICACY ITT   SAFETY\n   <chr>       <chr>    <chr>    <chr>   <chr>    <chr> <chr> \n 1 01-701-1015 Y        Y        Y       Y        Y     Y     \n 2 01-701-1023 <NA>     <NA>     <NA>    Y        Y     Y     \n 3 01-701-1028 Y        Y        Y       Y        Y     Y     \n 4 01-701-1033 <NA>     <NA>     <NA>    Y        Y     Y     \n 5 01-701-1034 Y        Y        Y       Y        Y     Y     \n 6 01-701-1047 <NA>     <NA>     <NA>    Y        Y     Y     \n 7 01-701-1097 Y        Y        Y       Y        Y     Y     \n 8 01-701-1111 <NA>     <NA>     <NA>    Y        Y     Y     \n 9 01-701-1115 <NA>     <NA>     Y       Y        Y     Y     \n10 01-701-1118 Y        Y        Y       Y        Y     Y     \n# … with 244 more rows\n```\n:::\n:::\n\n\nVoila! This \"wide\" dataset may prove useful for joins (to be discussed later). But for now, let's pretend that this \"wide\" format is how our original data came to us in. If we wanted to take these respective flagging columns and turn them into a \"long\" format, we use `pivot_longer()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppdm_long <- suppdm_wide %>% \n  pivot_longer(cols = c(\"COMPLT16\", \"COMPLT24\", \"COMPLT8\", \"EFFICACY\", \"ITT\", \"SAFETY\"), \n               names_to = \"QNAM\",\n               values_to = \"QVAL\")\nsuppdm_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,524 × 3\n   USUBJID     QNAM     QVAL \n   <chr>       <chr>    <chr>\n 1 01-701-1015 COMPLT16 Y    \n 2 01-701-1015 COMPLT24 Y    \n 3 01-701-1015 COMPLT8  Y    \n 4 01-701-1015 EFFICACY Y    \n 5 01-701-1015 ITT      Y    \n 6 01-701-1015 SAFETY   Y    \n 7 01-701-1023 COMPLT16 <NA> \n 8 01-701-1023 COMPLT24 <NA> \n 9 01-701-1023 COMPLT8  <NA> \n10 01-701-1023 EFFICACY Y    \n# … with 1,514 more rows\n```\n:::\n:::\n\n\nAs you can see, as we pivoted back, we didn't come up with an *exact* duplicate of our original `suppdm` dataframe. This is because the default of `pivot_longer()` is **not** to drop `NA` values, which can be modified with the `values_drop_na` function input, just one of the many powerful additional function inputs from both of these pivoting functions. `pivot_wider()` and `pivot_longer()` were designed to handle a variety of situations when transposing data in the most flexible of ways.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppdm_long <- suppdm_wide %>% \n  pivot_longer(cols = c(\"COMPLT16\", \"COMPLT24\", \"COMPLT8\", \"EFFICACY\", \"ITT\", \"SAFETY\"), \n               names_to = \"flag\",\n               values_to = \"flag_value\",\n               values_drop_na = TRUE)\nsuppdm_long\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,197 × 3\n   USUBJID     flag     flag_value\n   <chr>       <chr>    <chr>     \n 1 01-701-1015 COMPLT16 Y         \n 2 01-701-1015 COMPLT24 Y         \n 3 01-701-1015 COMPLT8  Y         \n 4 01-701-1015 EFFICACY Y         \n 5 01-701-1015 ITT      Y         \n 6 01-701-1015 SAFETY   Y         \n 7 01-701-1023 EFFICACY Y         \n 8 01-701-1023 ITT      Y         \n 9 01-701-1023 SAFETY   Y         \n10 01-701-1028 COMPLT16 Y         \n# … with 1,187 more rows\n```\n:::\n:::\n\n\nBonus Trick: The `names_to`/`values_to` function arguments can prove to be helpful as a renaming step during the data cleaning process too!\n\n# Relational Data (Joins)\n\nWhen a pair of tables need to be joined together, we have a variety of functions that can achieve such a task:\n\n-   `left_join()`\n\n-   `right_join()`\n\n-   `full_join()`\n\n-   `inner_join()`\n\nThe use of these functions is very similar to `proc sql` in SAS. `left_join()` will cover most of use cases and is demonstrated below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndm <- admiral.test::admiral_dm %>% \n  select(STUDYID, USUBJID, AGE, ARM)\n\ndm_suppdm <- dm %>% \n  left_join(suppdm_wide, by = \"USUBJID\")\n\nhead(dm_suppdm)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 10\n  STUDYID      USUBJID    AGE ARM   COMPL…¹ COMPL…² COMPLT8 EFFIC…³ ITT   SAFETY\n  <chr>        <chr>    <dbl> <chr> <chr>   <chr>   <chr>   <chr>   <chr> <chr> \n1 CDISCPILOT01 01-701-…    63 Plac… Y       Y       Y       Y       Y     Y     \n2 CDISCPILOT01 01-701-…    64 Plac… <NA>    <NA>    <NA>    Y       Y     Y     \n3 CDISCPILOT01 01-701-…    71 Xano… Y       Y       Y       Y       Y     Y     \n4 CDISCPILOT01 01-701-…    74 Xano… <NA>    <NA>    <NA>    Y       Y     Y     \n5 CDISCPILOT01 01-701-…    77 Xano… Y       Y       Y       Y       Y     Y     \n6 CDISCPILOT01 01-701-…    85 Plac… <NA>    <NA>    <NA>    Y       Y     Y     \n# … with abbreviated variable names ¹​COMPLT16, ²​COMPLT24, ³​EFFICACY\n```\n:::\n:::\n\n\nThe join can also be completed with different column names as long as you define the join-key relationship, demonstrated below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndummy1 <- data.frame(STUDYID = c(\"TRIALX\", \"TRIALX\"),\n                     USUBJID = c(\"1001\", \"1002\"),\n                     AGE = c(18, 22))\n\ndummy2 <- data.frame(STUDYID = c(\"TRIALX\", \"TRIALX\"),\n                     SUBJECT = c(\"1001\", \"1002\"),\n                     SEX = c(\"M\", \"F\"))\n\ndummy3 <- dummy1 %>% \n  left_join(dummy2, by = c(\"STUDYID\" = \"STUDYID\", \"USUBJID\" = \"SUBJECT\"))\n\nhead(dummy3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  STUDYID USUBJID AGE SEX\n1  TRIALX    1001  18   M\n2  TRIALX    1002  22   F\n```\n:::\n:::\n",
    "supporting": [
      "tidyr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}