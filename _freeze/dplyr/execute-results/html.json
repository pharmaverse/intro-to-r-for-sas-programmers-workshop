{
  "hash": "88e92017fa787dcb91b4e3b5b068224c",
  "result": {
    "markdown": "---\ntitle: \"dplyr\"\nauthor: \"Stefan\"\nformat: html\neditor: visual\n---\n\n\n## Setup\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# remotes::install_github(\"https://github.com/pharmaverse/admiral\")\n# library(admiral)\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching packages ─────────────────────────────────────── tidyverse 1.3.2 ──\n✔ ggplot2 3.4.0      ✔ purrr   1.0.1 \n✔ tibble  3.1.8      ✔ dplyr   1.0.10\n✔ tidyr   1.2.1      ✔ stringr 1.5.0 \n✔ readr   2.1.3      ✔ forcats 0.5.2 \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl <- haven::read_sas(\"data/adsl.sas7bdat\") %>% \n  mutate_if(is_character, na_if, \"\")\n```\n:::\n\n\nWe can have a look at the data using many different commands / functions, e.g. the `head()` function which gives us the first six observations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(adsl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 50\n  STUDYID  USUBJID SUBJID RFSTDTC RFENDTC RFXST…¹ RFXEN…² RFICDTC RFPEN…³ DTHDTC\n  <chr>    <chr>   <chr>  <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr> \n1 CDISCPI… 01-701… 1015   2014-0… 2014-0… 2014-0… 2014-0… <NA>    2014-0… <NA>  \n2 CDISCPI… 01-701… 1023   2012-0… 2012-0… 2012-0… 2012-0… <NA>    2013-0… <NA>  \n3 CDISCPI… 01-701… 1028   2013-0… 2014-0… 2013-0… 2014-0… <NA>    2014-0… <NA>  \n4 CDISCPI… 01-701… 1033   2014-0… 2014-0… 2014-0… 2014-0… <NA>    2014-0… <NA>  \n5 CDISCPI… 01-701… 1034   2014-0… 2014-1… 2014-0… 2014-1… <NA>    2014-1… <NA>  \n6 CDISCPI… 01-701… 1047   2013-0… 2013-0… 2013-0… 2013-0… <NA>    2013-0… <NA>  \n# … with 40 more variables: DTHFL <chr>, SITEID <chr>, AGE <dbl>, AGEU <chr>,\n#   SEX <chr>, RACE <chr>, ETHNIC <chr>, ARMCD <chr>, ARM <chr>,\n#   ACTARMCD <chr>, ACTARM <chr>, COUNTRY <chr>, DMDTC <chr>, DMDY <dbl>,\n#   TRT01P <chr>, TRT01A <chr>, TRTSDTM <dttm>, TRTSTMF <chr>, TRTEDTM <dttm>,\n#   TRTETMF <chr>, TRTSDT <date>, TRTEDT <date>, TRTDURD <dbl>, SCRFDT <date>,\n#   EOSDT <date>, EOSSTT <chr>, FRVDT <date>, RANDDT <date>, DTHDT <date>,\n#   DTHADY <dbl>, LDDTHELD <dbl>, LSTALVDT <date>, AGEGR1 <dbl>, SAFFL <chr>, …\n```\n:::\n:::\n\n\n## `dplyr`\n\n`dplyr` is a package which is part of the tidyverse. `dplyr` helps us handle data. In R, we generally work with data-sets. With `dplyr` we can easily select variables, filter specific rows, sort data-sets based on variable values and much more.\n\n`dplyr` is not strictly needed for any of that, everything can be done in base R. However, `dplyr` provides a framework to write readable code and a pipeline to work efficiently.\n\n<!-- The most crucial aspect of the `dplyr` pipeline is the pipe command (%\\>%). The pipe operator (ctrl shift m) uses the previously computed object and forwards it to the next function as the first argument. It can also be specified to be some other argument of the next function. Let's show a simple example: -->\n\n<!-- ```{r} -->\n\n<!-- vec <- 1:10 -->\n\n<!-- # base: -->\n\n<!-- mean(vec) -->\n\n<!-- # dplyr: -->\n\n<!-- vec %>% mean() -->\n\n<!-- ``` -->\n\n<!-- The pipe operator let's us write nested function calls in a sequential way. For example, we can calculate the rounded variance of the centered vector `vec`: -->\n\n<!-- ```{r} -->\n\n<!-- # base: -->\n\n<!-- round(var(scale(vec, scale = FALSE)), digits = 2) -->\n\n<!-- # dplyr: -->\n\n<!-- vec %>%  -->\n\n<!--   scale(scale = FALSE) %>%  -->\n\n<!--   var() %>%  -->\n\n<!--   round(digits = 2) -->\n\n<!-- ``` -->\n\n<!-- However, most often, the pipe takes a dataset (or a modified dataset) and forwards it into the next function as the data argument of the next function. -->\n\n## Datawrangling\n\nThere are various functions within `dplyr` for datawrangling which follow a consistent structure. The first input of the most used dplyr functions is the data-frame. Then follow arguments specifying the behaviour of the function. Compared to the base r syntax we do not have to write column / variable names in quotation marks; `dplyr` syntax lets us refer to columns within a data-frame without the need to always reference the dataframe of origin.\n\n### select\n\nThe `select` function lets us select all variables mentioned in the arguments (and drops all other variables). Alternatively, we can selectively drop variables if we place a minus (`-`) in front of the variable name.\\\nWe can first have a look at all variable names of the data-frame:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(adsl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"STUDYID\"  \"USUBJID\"  \"SUBJID\"   \"RFSTDTC\"  \"RFENDTC\"  \"RFXSTDTC\"\n [7] \"RFXENDTC\" \"RFICDTC\"  \"RFPENDTC\" \"DTHDTC\"   \"DTHFL\"    \"SITEID\"  \n[13] \"AGE\"      \"AGEU\"     \"SEX\"      \"RACE\"     \"ETHNIC\"   \"ARMCD\"   \n[19] \"ARM\"      \"ACTARMCD\" \"ACTARM\"   \"COUNTRY\"  \"DMDTC\"    \"DMDY\"    \n[25] \"TRT01P\"   \"TRT01A\"   \"TRTSDTM\"  \"TRTSTMF\"  \"TRTEDTM\"  \"TRTETMF\" \n[31] \"TRTSDT\"   \"TRTEDT\"   \"TRTDURD\"  \"SCRFDT\"   \"EOSDT\"    \"EOSSTT\"  \n[37] \"FRVDT\"    \"RANDDT\"   \"DTHDT\"    \"DTHADY\"   \"LDDTHELD\" \"LSTALVDT\"\n[43] \"AGEGR1\"   \"SAFFL\"    \"RACEGR1\"  \"REGION1\"  \"LDDTHGR1\" \"DTH30FL\" \n[49] \"DTHA30FL\" \"DTHB30FL\"\n```\n:::\n:::\n\n\nAnd then select the desired variables:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# dplyr::select\nselect(.data = adsl, \n       STUDYID, \n       USUBJID, \n       ARM, \n       AGE, \n       SEX, \n       RACE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 6\n   STUDYID      USUBJID     ARM                    AGE SEX   RACE \n   <chr>        <chr>       <chr>                <dbl> <chr> <chr>\n 1 CDISCPILOT01 01-701-1015 Placebo                 63 F     WHITE\n 2 CDISCPILOT01 01-701-1023 Placebo                 64 M     WHITE\n 3 CDISCPILOT01 01-701-1028 Xanomeline High Dose    71 M     WHITE\n 4 CDISCPILOT01 01-701-1033 Xanomeline Low Dose     74 M     WHITE\n 5 CDISCPILOT01 01-701-1034 Xanomeline High Dose    77 F     WHITE\n 6 CDISCPILOT01 01-701-1047 Placebo                 85 F     WHITE\n 7 CDISCPILOT01 01-701-1057 Screen Failure          59 F     WHITE\n 8 CDISCPILOT01 01-701-1097 Xanomeline Low Dose     68 M     WHITE\n 9 CDISCPILOT01 01-701-1111 Xanomeline Low Dose     81 F     WHITE\n10 CDISCPILOT01 01-701-1115 Xanomeline Low Dose     84 M     WHITE\n# … with 296 more rows\n```\n:::\n:::\n\n\nWe end up with a new data-frame including only the selected variables. Note here that we do not save the resulting data-frame at the moment.\n\nThere are also some helper functions to use within the `select` function of `dplyr`. `starts_with()` `ends_with()` `num_range()`. They allow us to select multiple columns sharing a naming structure. `num_range()` let's us select consecutively numbered columns, e.g.: `num_range(\"example\", 1:4)` would select the columns named: example1, example2, example3, example4.\n\nWe can try out `starts_with()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(adsl,\n       USUBJID, \n       starts_with(\"trt\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 10\n   USUBJID TRT01P TRT01A TRTSDTM             TRTSTMF TRTEDTM             TRTETMF\n   <chr>   <chr>  <chr>  <dttm>              <chr>   <dttm>              <chr>  \n 1 01-701… Place… Place… 2014-01-02 00:00:00 H       2014-07-02 23:59:59 H      \n 2 01-701… Place… Place… 2012-08-05 00:00:00 H       2012-09-01 23:59:59 H      \n 3 01-701… Xanom… Xanom… 2013-07-19 00:00:00 H       2014-01-14 23:59:59 H      \n 4 01-701… Xanom… Xanom… 2014-03-18 00:00:00 H       2014-03-31 23:59:59 H      \n 5 01-701… Xanom… Xanom… 2014-07-01 00:00:00 H       2014-12-30 23:59:59 H      \n 6 01-701… Place… Place… 2013-02-12 00:00:00 H       2013-03-09 23:59:59 H      \n 7 01-701… Scree… Scree… NA                  <NA>    NA                  <NA>   \n 8 01-701… Xanom… Xanom… 2014-01-01 00:00:00 H       2014-07-09 23:59:59 H      \n 9 01-701… Xanom… Xanom… 2012-09-07 00:00:00 H       2012-09-16 23:59:59 H      \n10 01-701… Xanom… Xanom… 2012-11-30 00:00:00 H       2013-01-23 23:59:59 H      \n# … with 296 more rows, and 3 more variables: TRTSDT <date>, TRTEDT <date>,\n#   TRTDURD <dbl>\n```\n:::\n:::\n\n\nAnd `ends_with()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# in this df, all variables that contain dates end with \"DT\". \n# We can select them:\nselect(adsl,\n       USUBJID, \n       ends_with(\"DT\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 9\n   USUBJID     TRTSDT     TRTEDT     SCRFDT     EOSDT      FRVDT      RANDDT    \n   <chr>       <date>     <date>     <date>     <date>     <date>     <date>    \n 1 01-701-1015 2014-01-02 2014-07-02 NA         2014-07-02 NA         2014-01-02\n 2 01-701-1023 2012-08-05 2012-09-01 NA         2012-09-02 2013-02-18 2012-08-05\n 3 01-701-1028 2013-07-19 2014-01-14 NA         2014-01-14 NA         2013-07-19\n 4 01-701-1033 2014-03-18 2014-03-31 NA         2014-04-14 2014-09-15 2014-03-18\n 5 01-701-1034 2014-07-01 2014-12-30 NA         2014-12-30 NA         2014-07-01\n 6 01-701-1047 2013-02-12 2013-03-09 NA         2013-03-29 2013-07-28 2013-02-12\n 7 01-701-1057 NA         NA         2013-12-20 NA         NA         NA        \n 8 01-701-1097 2014-01-01 2014-07-09 NA         2014-07-09 NA         2014-01-01\n 9 01-701-1111 2012-09-07 2012-09-16 NA         2012-09-17 2013-02-22 2012-09-07\n10 01-701-1115 2012-11-30 2013-01-23 NA         2013-01-23 2013-05-20 2012-11-30\n# … with 296 more rows, and 2 more variables: DTHDT <date>, LSTALVDT <date>\n```\n:::\n:::\n\n\nIf we want a data-frame that does not include any dates, we can make use of the minus sign in combination with the `ends_with()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(adsl,\n       -ends_with(\"DT\")) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 42\n   STUDYID USUBJID SUBJID RFSTDTC RFENDTC RFXST…¹ RFXEN…² RFICDTC RFPEN…³ DTHDTC\n   <chr>   <chr>   <chr>  <chr>   <chr>   <chr>   <chr>   <chr>   <chr>   <chr> \n 1 CDISCP… 01-701… 1015   2014-0… 2014-0… 2014-0… 2014-0… <NA>    2014-0… <NA>  \n 2 CDISCP… 01-701… 1023   2012-0… 2012-0… 2012-0… 2012-0… <NA>    2013-0… <NA>  \n 3 CDISCP… 01-701… 1028   2013-0… 2014-0… 2013-0… 2014-0… <NA>    2014-0… <NA>  \n 4 CDISCP… 01-701… 1033   2014-0… 2014-0… 2014-0… 2014-0… <NA>    2014-0… <NA>  \n 5 CDISCP… 01-701… 1034   2014-0… 2014-1… 2014-0… 2014-1… <NA>    2014-1… <NA>  \n 6 CDISCP… 01-701… 1047   2013-0… 2013-0… 2013-0… 2013-0… <NA>    2013-0… <NA>  \n 7 CDISCP… 01-701… 1057   <NA>    <NA>    <NA>    <NA>    <NA>    2013-1… <NA>  \n 8 CDISCP… 01-701… 1097   2014-0… 2014-0… 2014-0… 2014-0… <NA>    2014-0… <NA>  \n 9 CDISCP… 01-701… 1111   2012-0… 2012-0… 2012-0… 2012-0… <NA>    2013-0… <NA>  \n10 CDISCP… 01-701… 1115   2012-1… 2013-0… 2012-1… 2013-0… <NA>    2013-0… <NA>  \n# … with 296 more rows, 32 more variables: DTHFL <chr>, SITEID <chr>,\n#   AGE <dbl>, AGEU <chr>, SEX <chr>, RACE <chr>, ETHNIC <chr>, ARMCD <chr>,\n#   ARM <chr>, ACTARMCD <chr>, ACTARM <chr>, COUNTRY <chr>, DMDTC <chr>,\n#   DMDY <dbl>, TRT01P <chr>, TRT01A <chr>, TRTSDTM <dttm>, TRTSTMF <chr>,\n#   TRTEDTM <dttm>, TRTETMF <chr>, TRTDURD <dbl>, EOSSTT <chr>, DTHADY <dbl>,\n#   LDDTHELD <dbl>, AGEGR1 <dbl>, SAFFL <chr>, RACEGR1 <chr>, REGION1 <chr>,\n#   LDDTHGR1 <chr>, DTH30FL <chr>, DTHA30FL <chr>, DTHB30FL <chr>, and …\n```\n:::\n:::\n\n\n::: {.callout-note appearance=\"simple\"}\n## Change order of variables\n\nWe can use the `select()` function to reorder the variables in the data-frame. This does not affect the order of rows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselect(adsl,\n         ARM, \n         USUBJID)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 2\n   ARM                  USUBJID    \n   <chr>                <chr>      \n 1 Placebo              01-701-1015\n 2 Placebo              01-701-1023\n 3 Xanomeline High Dose 01-701-1028\n 4 Xanomeline Low Dose  01-701-1033\n 5 Xanomeline High Dose 01-701-1034\n 6 Placebo              01-701-1047\n 7 Screen Failure       01-701-1057\n 8 Xanomeline Low Dose  01-701-1097\n 9 Xanomeline Low Dose  01-701-1111\n10 Xanomeline Low Dose  01-701-1115\n# … with 296 more rows\n```\n:::\n:::\n\n:::\n\n### filter\n\nThe `filter` function allows us to look at a subset of observations. As input, the function requires a logical vector and (of course) a data-frame. This time, we first save the reduced (selected) data-frame and use that as the first argument to `filter`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselected_data <- select(adsl, \n                        STUDYID, \n                        USUBJID, \n                        ARM, \n                        AGE, \n                        SEX, \n                        RACE)\n```\n:::\n\n\nThe logical vector is generally created within the function call and can use any of the following logic operators:\n\n    <                less than\n    <=               less than or equal to\n    >                greater than\n    >=               greater than or equal to\n    ==               equal\n    !=               not equal\n    !x               not x (negation)\n    x | y            x OR y\n    x & y            x AND y\n    x %in% y         logical vector of length x with TRUE if element of x is in y \n\nWithin `filter`, we can chain logical vectors by separating them with a comma (`,`). Lets have a look at women that are 70 and older:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter(selected_data,\n       AGE >= 70,\n       SEX == \"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM                    AGE SEX   RACE               \n   <chr>        <chr>       <chr>                <dbl> <chr> <chr>              \n 1 CDISCPILOT01 01-701-1034 Xanomeline High Dose    77 F     WHITE              \n 2 CDISCPILOT01 01-701-1047 Placebo                 85 F     WHITE              \n 3 CDISCPILOT01 01-701-1111 Xanomeline Low Dose     81 F     WHITE              \n 4 CDISCPILOT01 01-701-1133 Xanomeline High Dose    81 F     WHITE              \n 5 CDISCPILOT01 01-701-1146 Xanomeline High Dose    75 F     WHITE              \n 6 CDISCPILOT01 01-701-1153 Placebo                 79 F     WHITE              \n 7 CDISCPILOT01 01-701-1162 Screen Failure          82 F     WHITE              \n 8 CDISCPILOT01 01-701-1181 Xanomeline High Dose    79 F     WHITE              \n 9 CDISCPILOT01 01-701-1192 Xanomeline Low Dose     80 F     WHITE              \n10 CDISCPILOT01 01-701-1203 Placebo                 81 F     BLACK OR AFRICAN A…\n# … with 131 more rows\n```\n:::\n:::\n\n\nNow we have a reduced data frame with female patients over 70. However, the nested call is not very intuitive to read. If any more functions get added to this code, it becomes even less readable. That is where the pipe operator (`%>%`) comes in.\n\n::: {.callout-note appearance=\"simple\"}\n## pipe\n\nThe pipe operator let us chain multiple `dplyr` commands, so we can always forward the previously filtered / selected / arranged dataframe and keep working with it. The pipe operator let's us write nested function calls in a sequential way. Traditionally, we start a new line after every pipe operator.\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# select, filter, & pipe:\nadsl %>% # This pipe forwards adsl to the select function as its first argument\n  select(STUDYID, \n         USUBJID,\n         ARM, \n         AGE, \n         SEX, \n         RACE) %>% # this pipe forwards the selected variables to the filter function\n  filter(AGE >= 70,\n         SEX == \"F\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM                    AGE SEX   RACE               \n   <chr>        <chr>       <chr>                <dbl> <chr> <chr>              \n 1 CDISCPILOT01 01-701-1034 Xanomeline High Dose    77 F     WHITE              \n 2 CDISCPILOT01 01-701-1047 Placebo                 85 F     WHITE              \n 3 CDISCPILOT01 01-701-1111 Xanomeline Low Dose     81 F     WHITE              \n 4 CDISCPILOT01 01-701-1133 Xanomeline High Dose    81 F     WHITE              \n 5 CDISCPILOT01 01-701-1146 Xanomeline High Dose    75 F     WHITE              \n 6 CDISCPILOT01 01-701-1153 Placebo                 79 F     WHITE              \n 7 CDISCPILOT01 01-701-1162 Screen Failure          82 F     WHITE              \n 8 CDISCPILOT01 01-701-1181 Xanomeline High Dose    79 F     WHITE              \n 9 CDISCPILOT01 01-701-1192 Xanomeline Low Dose     80 F     WHITE              \n10 CDISCPILOT01 01-701-1203 Placebo                 81 F     BLACK OR AFRICAN A…\n# … with 131 more rows\n```\n:::\n:::\n\n\nThere is another inline operator which can be very useful within the filter function; `%in%`. With this operator, we can select rows based on a prespecified vector of values. This can be useful if there are specified values (e.g., specific `USUBJID`) which we would like to look at.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we save 4 USUBJID's in a vector:\nlookup_ids <- c(\"01-716-1151\", \"01-710-1443\", \"01-708-1184\", \"01-705-1186\")\n\n\n# and then create a logical vector which returns TRUE for every entry in the \n# USUBJID vector which are represented in the lookup_ids, and else FALSE\nadsl$USUBJID %in% lookup_ids\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n [97] FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE\n[109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[133] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[217] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[265] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[301] FALSE FALSE FALSE FALSE FALSE FALSE\n```\n:::\n\n```{.r .cell-code}\n# this approach can be used in the filter function: \nadsl %>% \n  select(STUDYID, USUBJID, ARM, AGE, SEX, RACE) %>% \n  filter(USUBJID %in% lookup_ids)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n  STUDYID      USUBJID     ARM                   AGE SEX   RACE \n  <chr>        <chr>       <chr>               <dbl> <chr> <chr>\n1 CDISCPILOT01 01-705-1186 Placebo                84 F     WHITE\n2 CDISCPILOT01 01-708-1184 Screen Failure         70 F     WHITE\n3 CDISCPILOT01 01-710-1443 Screen Failure         88 F     WHITE\n4 CDISCPILOT01 01-716-1151 Xanomeline Low Dose    83 F     WHITE\n```\n:::\n:::\n\n\nNote that within the `filter` function (and in all major `dplyr` functions) R looks for the requested variables first within the supplied data-frame and afterwards in the global environment.\n\n### arrange\n\nWe can sort the dataframe with the arrange() function. It allows the sorting based on multiple variables. Note that the order of arranging variables determines the sorting hierarchy, so in this example we first order by `AGE` and\n\n\n::: {.cell}\n\n```{.r .cell-code}\n adsl %>% \n  select(STUDYID, USUBJID, ARM, AGE, SEX, RACE) %>% \n  filter(AGE >= 70,\n         SEX == \"F\") %>% \n  arrange(ARM, AGE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM       AGE SEX   RACE                     \n   <chr>        <chr>       <chr>   <dbl> <chr> <chr>                    \n 1 CDISCPILOT01 01-705-1282 Placebo    70 F     BLACK OR AFRICAN AMERICAN\n 2 CDISCPILOT01 01-704-1260 Placebo    71 F     WHITE                    \n 3 CDISCPILOT01 01-703-1210 Placebo    72 F     WHITE                    \n 4 CDISCPILOT01 01-716-1026 Placebo    73 F     WHITE                    \n 5 CDISCPILOT01 01-718-1150 Placebo    73 F     WHITE                    \n 6 CDISCPILOT01 01-708-1087 Placebo    74 F     WHITE                    \n 7 CDISCPILOT01 01-708-1316 Placebo    74 F     WHITE                    \n 8 CDISCPILOT01 01-709-1001 Placebo    76 F     WHITE                    \n 9 CDISCPILOT01 01-710-1077 Placebo    76 F     WHITE                    \n10 CDISCPILOT01 01-715-1397 Placebo    76 F     WHITE                    \n# … with 131 more rows\n```\n:::\n:::\n\n\nTo sort by descending order, we can use the helper function `desc()` within `arrange()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n adsl %>% \n  select(STUDYID, USUBJID, ARM, AGE, SEX, RACE) %>% \n  filter(AGE >= 70,\n         SEX == \"F\") %>% \n  arrange(ARM, desc(AGE))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 141 × 6\n   STUDYID      USUBJID     ARM       AGE SEX   RACE \n   <chr>        <chr>       <chr>   <dbl> <chr> <chr>\n 1 CDISCPILOT01 01-710-1083 Placebo    89 F     WHITE\n 2 CDISCPILOT01 01-710-1368 Placebo    88 F     WHITE\n 3 CDISCPILOT01 01-714-1035 Placebo    88 F     WHITE\n 4 CDISCPILOT01 01-701-1387 Placebo    87 F     WHITE\n 5 CDISCPILOT01 01-704-1233 Placebo    87 F     WHITE\n 6 CDISCPILOT01 01-716-1024 Placebo    87 F     WHITE\n 7 CDISCPILOT01 01-705-1349 Placebo    86 F     WHITE\n 8 CDISCPILOT01 01-710-1271 Placebo    86 F     WHITE\n 9 CDISCPILOT01 01-716-1108 Placebo    86 F     WHITE\n10 CDISCPILOT01 01-701-1047 Placebo    85 F     WHITE\n# … with 131 more rows\n```\n:::\n:::\n",
    "supporting": [
      "dplyr_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}