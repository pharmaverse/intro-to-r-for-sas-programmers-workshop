{
  "hash": "b69fa0ee7c9059c3990826b3c3719013",
  "result": {
    "markdown": "---\ntitle: \"mutate\"\nsubtitle: \"Creating New Columns Using `mutate()`\"\nauthor: \"Thomas\"\nformat: html\neditor: visual\n---\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(lubridate)\ndm <- readRDS(\"data/dm.rds\")\nae <- readRDS(\"data/ae.rds\")\n```\n:::\n\n\nThe equivalent of creating a new variables in SAS inside a `data` step is to use the `mutate()` function. In the simplest case a static value is assigned to the new column.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl <- dm %>% mutate(DATASET = \"ADSL\")\n```\n:::\n\n\nThis will set the value of the new variable `DATASET` to `\"ADSL\"` for all records.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl %>% select(DATASET)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 1\n   DATASET\n   <chr>  \n 1 ADSL   \n 2 ADSL   \n 3 ADSL   \n 4 ADSL   \n 5 ADSL   \n 6 ADSL   \n 7 ADSL   \n 8 ADSL   \n 9 ADSL   \n10 ADSL   \n# … with 296 more rows\n```\n:::\n:::\n\n\nNote that new variables are always appended after existing columns such that `DATASET` is now the last column of `adsl`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(adsl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"STUDYID\"  \"DOMAIN\"   \"USUBJID\"  \"SUBJID\"   \"RFSTDTC\"  \"RFENDTC\" \n [7] \"RFXSTDTC\" \"RFXENDTC\" \"RFICDTC\"  \"RFPENDTC\" \"DTHDTC\"   \"DTHFL\"   \n[13] \"SITEID\"   \"AGE\"      \"AGEU\"     \"SEX\"      \"RACE\"     \"ETHNIC\"  \n[19] \"ARMCD\"    \"ARM\"      \"ACTARMCD\" \"ACTARM\"   \"COUNTRY\"  \"DMDTC\"   \n[25] \"DMDY\"     \"DATASET\" \n```\n:::\n:::\n\n\nAssigning the value of an existing column to a new column is the same as in SAS. The new column name goes to the left of `=` and the existing column to the right.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl <- adsl %>% mutate(TRT01P = ARM)\nadsl %>% select(ARM, TRT01P)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 2\n   ARM                  TRT01P              \n   <chr>                <chr>               \n 1 Placebo              Placebo             \n 2 Placebo              Placebo             \n 3 Xanomeline High Dose Xanomeline High Dose\n 4 Xanomeline Low Dose  Xanomeline Low Dose \n 5 Xanomeline High Dose Xanomeline High Dose\n 6 Placebo              Placebo             \n 7 Screen Failure       Screen Failure      \n 8 Xanomeline Low Dose  Xanomeline Low Dose \n 9 Xanomeline Low Dose  Xanomeline Low Dose \n10 Xanomeline Low Dose  Xanomeline Low Dose \n# … with 296 more rows\n```\n:::\n:::\n\n\nIn most cases new variables are created by applying function on existing variables to somehow transform them.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl <- adsl %>% mutate(RFSTDT = ymd(RFSTDTC))\n```\n:::\n\n\nJust like you can create multiple new variables inside a `data` step you can do so inside `mutate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadae <- ae %>% mutate(\n  ASTDT = ymd(AESTDTC),\n  ASTDY = ASTDT - TRTSDT + 1\n)\nadae %>% select(AESTDTC, ASTDT, TRTSDT, ASTDY)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,191 × 4\n   AESTDTC    ASTDT      TRTSDT     ASTDY  \n   <chr>      <date>     <date>     <drtn> \n 1 2014-01-03 2014-01-03 2014-01-02  2 days\n 2 2014-01-03 2014-01-03 2014-01-02  2 days\n 3 2014-01-09 2014-01-09 2014-01-02  8 days\n 4 2012-08-26 2012-08-26 2012-08-05 22 days\n 5 2012-08-07 2012-08-07 2012-08-05  3 days\n 6 2012-08-07 2012-08-07 2012-08-05  3 days\n 7 2012-08-07 2012-08-07 2012-08-05  3 days\n 8 2013-07-21 2013-07-21 2013-07-19  3 days\n 9 2013-08-08 2013-08-08 2013-07-19 21 days\n10 2014-08-27 2014-08-27 2014-07-01 58 days\n# … with 1,181 more rows\n```\n:::\n:::\n\n\nJust like in SAS you can use conditional logic to assign different values to a new variable depending on which value another variable has using `if_else()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadae %>%\n  mutate(ASTDY = if_else(ASTDT <= TRTSDT, ASTDT - TRTSDT, ASTDT - TRTSDT + 1)) %>% \n  select(USUBJID, TRTSDT, ASTDT, ASTDY)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 1,191 × 4\n   USUBJID     TRTSDT     ASTDT      ASTDY  \n   <chr>       <date>     <date>     <drtn> \n 1 01-701-1015 2014-01-02 2014-01-03  2 days\n 2 01-701-1015 2014-01-02 2014-01-03  2 days\n 3 01-701-1015 2014-01-02 2014-01-09  8 days\n 4 01-701-1023 2012-08-05 2012-08-26 22 days\n 5 01-701-1023 2012-08-05 2012-08-07  3 days\n 6 01-701-1023 2012-08-05 2012-08-07  3 days\n 7 01-701-1023 2012-08-05 2012-08-07  3 days\n 8 01-701-1028 2013-07-19 2013-07-21  3 days\n 9 01-701-1028 2013-07-19 2013-08-08 21 days\n10 01-701-1034 2014-07-01 2014-08-27 58 days\n# … with 1,181 more rows\n```\n:::\n:::\n\n\nAt this point let's make a small excursion to cover how R handles missing values, i.e. `NA`, when using conditional logic. Unlike in SAS where missing numbers are the smallest possible values such that `. < 10` is true, in R any comparison involving `NA` returns `NA` as a result.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNA < 9\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n\n```{.r .cell-code}\nNA == 0\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] NA\n```\n:::\n:::\n\n\nThis is the same when using `if_else()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl$AGE[1] <- NA\ndm %>% \n  mutate(AGEGR = if_else(AGE >= 65, \"Elderly\", \"Adult\")) %>% \n  select(USUBJID, AGE, AGEGR)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR  \n   <chr>       <int> <chr>  \n 1 01-701-1015    63 Adult  \n 2 01-701-1023    64 Adult  \n 3 01-701-1028    71 Elderly\n 4 01-701-1033    74 Elderly\n 5 01-701-1034    77 Elderly\n 6 01-701-1047    85 Elderly\n 7 01-701-1057    59 Adult  \n 8 01-701-1097    68 Elderly\n 9 01-701-1111    81 Elderly\n10 01-701-1115    84 Elderly\n# … with 296 more rows\n```\n:::\n:::\n\n\nTo check whether a value is missing use the `is.na()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(NA)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\nis.na(\"NA\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE\n```\n:::\n:::\n\n\nFinally, it's noteworthy that is are actually different types on `NA`s in R. We'll make use of them next.\n\n| Type        | Example    | Missing Value   |\n|-------------|------------|-----------------|\n| `character` | `\"Brazil\"` | `NA_character_` |\n| `double`    | `2.51`     | `NA_real_`      |\n| `integer`   | `1L`       | `NA_integer_`   |\n| `logical`   | `FALSE`    | `NA`            |\n\n: Types of \\`NA\\` in R\n\nIf the logic is more complex than a simple `if_else()` than use `case_when()` instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      TRUE ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA >=65  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n```\n:::\n:::\n\n\nThe final condition `TRUE` is the is a catch all term and must be used with some caution. Consider what happens for the `AGE` of the first subject whose value we set to `NA` above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      TRUE ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA >=65  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n```\n:::\n:::\n\n\nTo mitigate this you should either explicitly handle missing values as a separate condition or be explicit for all cases. The former would look something like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      is.na(AGE) ~ NA_character_,\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      TRUE ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA <NA>  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n```\n:::\n:::\n\n\nAnd the latter like this.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\",\n      AGE >= 65 ~ \">=65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA <NA>  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 >=65  \n 4 01-701-1033    74 >=65  \n 5 01-701-1034    77 >=65  \n 6 01-701-1047    85 >=65  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 >=65  \n 9 01-701-1111    81 >=65  \n10 01-701-1115    84 >=65  \n# … with 296 more rows\n```\n:::\n:::\n\n\nFinally, note that when a value does not match any of the conditions given which may be the case when not using a final `TRUE` then it is assigned `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadsl %>% \n  mutate(\n    AGEGR1 = case_when(\n      AGE < 18 ~ \"<18\",\n      AGE < 45 ~ \"<45\",\n      AGE < 65 ~ \"<65\"\n    ) \n  ) %>% \n  select(USUBJID, AGE, AGEGR1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 306 × 3\n   USUBJID       AGE AGEGR1\n   <chr>       <int> <chr> \n 1 01-701-1015    NA <NA>  \n 2 01-701-1023    64 <65   \n 3 01-701-1028    71 <NA>  \n 4 01-701-1033    74 <NA>  \n 5 01-701-1034    77 <NA>  \n 6 01-701-1047    85 <NA>  \n 7 01-701-1057    59 <65   \n 8 01-701-1097    68 <NA>  \n 9 01-701-1111    81 <NA>  \n10 01-701-1115    84 <NA>  \n# … with 296 more rows\n```\n:::\n:::\n",
    "supporting": [
      "mutate_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}